<html><head>
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-LEEFT9748K"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-LEEFT9748K');
</script>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=DM+Sans&display=swap" rel="stylesheet">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Lab 1.1 Twitter Timeline</title><style>

body, h1, h2, h3, a, p {
	font-family: 'DM Sans', sans-serif;
	letter-spacing: .02em;
	font-size: 1.2rem;
}

/* cspell:disable-file */
/* webkit printing magic: print all background colors */
html {
	-webkit-print-color-adjust: exact;
}
* {
	box-sizing: border-box;
	-webkit-print-color-adjust: exact;
}

html,
body {
	margin: 0;
	padding: 0;
}
@media only screen {
	body {
		margin: 2em auto;
		max-width: 900px;
		color: rgb(55, 53, 47);
	}
}

body {
	line-height: 1.5;
	white-space: pre-wrap;
}

a,
a.visited {
	color: inherit;
	text-decoration: underline;
}

.pdf-relative-link-path {
	font-size: 80%;
	color: #444;
}

h1,
h2,
h3 {
	letter-spacing: -0.01em;
	line-height: 1.2;
	font-weight: 600;
	margin-bottom: 0;
}

.page-title {
	font-size: 2.5rem;
	font-weight: 700;
	margin-top: 0;
	margin-bottom: 0.75em;
}

h1 {
	font-size: 1.875rem;
	margin-top: 1.875rem;
}

h2 {
	font-size: 1.5rem;
	margin-top: 1.5rem;
}

h3 {
	font-size: 1.25rem;
	margin-top: 1.25rem;
}

.source {
	border: 1px solid #ddd;
	border-radius: 3px;
	padding: 1.5em;
	word-break: break-all;
}

.callout {
	border-radius: 3px;
	padding: 1rem;
}

figure {
	margin: 1.25em 0;
	page-break-inside: avoid;
}

figcaption {
	opacity: 0.5;
	font-size: 85%;
	margin-top: 0.5em;
}

mark {
	background-color: transparent;
}

.indented {
	padding-left: 1.5em;
}

hr {
	background: transparent;
	display: block;
	width: 100%;
	height: 1px;
	visibility: visible;
	border: none;
	border-bottom: 1px solid rgba(55, 53, 47, 0.09);
}

img {
	max-width: 100%;
}

@media only print {
	img {
		max-height: 100vh;
		object-fit: contain;
	}
}

@page {
	margin: 1in;
}

.collection-content {
	font-size: 0.875rem;
}

.column-list {
	display: flex;
	justify-content: space-between;
}

.column {
	padding: 0 1em;
}

.column:first-child {
	padding-left: 0;
}

.column:last-child {
	padding-right: 0;
}

.table_of_contents-item {
	display: block;
	font-size: 0.875rem;
	line-height: 1.3;
	padding: 0.125rem;
}

.table_of_contents-indent-1 {
	margin-left: 1.5rem;
}

.table_of_contents-indent-2 {
	margin-left: 3rem;
}

.table_of_contents-indent-3 {
	margin-left: 4.5rem;
}

.table_of_contents-link {
	text-decoration: none;
	opacity: 0.7;
	border-bottom: 1px solid rgba(55, 53, 47, 0.18);
}

table,
th,
td {
	border: 1px solid rgba(55, 53, 47, 0.09);
	border-collapse: collapse;
}

table {
	border-left: none;
	border-right: none;
}

th,
td {
	font-weight: normal;
	padding: 0.25em 0.5em;
	line-height: 1.5;
	min-height: 1.5em;
	text-align: left;
}

th {
	color: rgba(55, 53, 47, 0.6);
}

ol,
ul {
	margin: 0;
	margin-block-start: 0.6em;
	margin-block-end: 0.6em;
}

li > ol:first-child,
li > ul:first-child {
	margin-block-start: 0.6em;
}

ul > li {
	list-style: disc;
}

ul.to-do-list {
	padding-inline-start: 0;
}

ul.to-do-list > li {
	list-style: none;
}

.to-do-children-checked {
	text-decoration: line-through;
	opacity: 0.375;
}

ul.toggle > li {
	list-style: none;
}

ul {
	padding-inline-start: 1.7em;
}

ul > li {
	padding-left: 0.1em;
}

ol {
	padding-inline-start: 1.6em;
}

ol > li {
	padding-left: 0.2em;
}

.mono ol {
	padding-inline-start: 2em;
}

.mono ol > li {
	text-indent: -0.4em;
}

.toggle {
	padding-inline-start: 0em;
	list-style-type: none;
}

/* Indent toggle children */
.toggle > li > details {
	padding-left: 1.7em;
}

.toggle > li > details > summary {
	margin-left: -1.1em;
}

.selected-value {
	display: inline-block;
	padding: 0 0.5em;
	background: rgba(206, 205, 202, 0.5);
	border-radius: 3px;
	margin-right: 0.5em;
	margin-top: 0.3em;
	margin-bottom: 0.3em;
	white-space: nowrap;
}

.collection-title {
	display: inline-block;
	margin-right: 1em;
}

.simple-table {
	margin-top: 1em;
	font-size: 0.875rem;
	empty-cells: show;
}
.simple-table td {
	height: 29px;
	min-width: 120px;
}

.simple-table th {
	height: 29px;
	min-width: 120px;
}

.simple-table-header-color {
	background: rgb(247, 246, 243);
	color: black;
}
.simple-table-header {
	font-weight: 500;
}

time {
	opacity: 0.5;
}

.icon {
	display: inline-block;
	max-width: 1.2em;
	max-height: 1.2em;
	text-decoration: none;
	vertical-align: text-bottom;
	margin-right: 0.5em;
}

img.icon {
	border-radius: 3px;
}

.user-icon {
	width: 1.5em;
	height: 1.5em;
	border-radius: 100%;
	margin-right: 0.5rem;
}

.user-icon-inner {
	font-size: 0.8em;
}

.text-icon {
	border: 1px solid #000;
	text-align: center;
}

.page-cover-image {
	display: block;
	object-fit: cover;
	width: 100%;
	max-height: 30vh;
}

.page-header-icon {
	font-size: 3rem;
	margin-bottom: 1rem;
}

.page-header-icon-with-cover {
	margin-top: -0.72em;
	margin-left: 0.07em;
}

.page-header-icon img {
	border-radius: 3px;
}

.link-to-page {
	margin: 1em 0;
	padding: 0;
	border: none;
	font-weight: 500;
}

p > .user {
	opacity: 0.5;
}

td > .user,
td > time {
	white-space: nowrap;
}

input[type="checkbox"] {
	transform: scale(1.5);
	margin-right: 0.6em;
	vertical-align: middle;
}

p {
	margin-top: 0.5em;
	margin-bottom: 0.5em;
}

.image {
	border: none;
	margin: 1.5em 0;
	padding: 0;
	border-radius: 0;
	text-align: center;
}

.code,
code {
	background: rgba(135, 131, 120, 0.15);
	border-radius: 3px;
	padding: 0.2em 0.4em;
	border-radius: 3px;
	font-size: 85%;
	tab-size: 2;
}

code {
	color: #eb5757;
}

.code {
	padding: 1.5em 1em;
}

.code-wrap {
	white-space: pre-wrap;
	word-break: break-all;
}

.code > code {
	background: none;
	padding: 0;
	font-size: 100%;
	color: inherit;
}

blockquote {
	font-size: 1.25em;
	margin: 1em 0;
	padding-left: 1em;
	border-left: 3px solid rgb(55, 53, 47);
}

.bookmark {
	text-decoration: none;
	max-height: 8em;
	padding: 0;
	display: flex;
	width: 100%;
	align-items: stretch;
}

.bookmark-title {
	font-size: 0.85em;
	overflow: hidden;
	text-overflow: ellipsis;
	height: 1.75em;
	white-space: nowrap;
}

.bookmark-text {
	display: flex;
	flex-direction: column;
}

.bookmark-info {
	flex: 4 1 180px;
	padding: 12px 14px 14px;
	display: flex;
	flex-direction: column;
	justify-content: space-between;
}

.bookmark-image {
	width: 33%;
	flex: 1 1 180px;
	display: block;
	position: relative;
	object-fit: cover;
	border-radius: 1px;
}

.bookmark-description {
	color: rgba(55, 53, 47, 0.6);
	font-size: 0.75em;
	overflow: hidden;
	max-height: 4.5em;
	word-break: break-word;
}

.bookmark-href {
	font-size: 0.75em;
	margin-top: 0.25em;
}

.sans { font-family: ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol"; }
.code { font-family: "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace; }
.serif { font-family: Lyon-Text, Georgia, ui-serif, serif; }
.mono { font-family: iawriter-mono, Nitti, Menlo, Courier, monospace; }
.pdf .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK JP'; }
.pdf:lang(zh-CN) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK SC'; }
.pdf:lang(zh-TW) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK TC'; }
.pdf:lang(ko-KR) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK KR'; }
.pdf .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK JP'; }
.pdf:lang(zh-CN) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK SC'; }
.pdf:lang(zh-TW) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK TC'; }
.pdf:lang(ko-KR) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK KR'; }
.pdf .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK JP'; }
.pdf:lang(zh-CN) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK SC'; }
.pdf:lang(zh-TW) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK TC'; }
.pdf:lang(ko-KR) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK KR'; }
.pdf .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK JP'; }
.pdf:lang(zh-CN) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK SC'; }
.pdf:lang(zh-TW) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK TC'; }
.pdf:lang(ko-KR) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK KR'; }
.highlight-default {
	color: rgba(55, 53, 47, 1);
}
.highlight-gray {
	color: rgba(120, 119, 116, 1);
	fill: rgba(120, 119, 116, 1);
}
.highlight-brown {
	color: rgba(159, 107, 83, 1);
	fill: rgba(159, 107, 83, 1);
}
.highlight-orange {
	color: rgba(217, 115, 13, 1);
	fill: rgba(217, 115, 13, 1);
}
.highlight-yellow {
	color: rgba(203, 145, 47, 1);
	fill: rgba(203, 145, 47, 1);
}
.highlight-teal {
	color: rgba(68, 131, 97, 1);
	fill: rgba(68, 131, 97, 1);
}
.highlight-blue {
	color: rgba(51, 126, 169, 1);
	fill: rgba(51, 126, 169, 1);
}
.highlight-purple {
	color: rgba(144, 101, 176, 1);
	fill: rgba(144, 101, 176, 1);
}
.highlight-pink {
	color: rgba(193, 76, 138, 1);
	fill: rgba(193, 76, 138, 1);
}
.highlight-red {
	color: rgba(212, 76, 71, 1);
	fill: rgba(212, 76, 71, 1);
}
.highlight-gray_background {
	background: rgba(241, 241, 239, 1);
}
.highlight-brown_background {
	background: rgba(244, 238, 238, 1);
}
.highlight-orange_background {
	background: rgba(251, 236, 221, 1);
}
.highlight-yellow_background {
	background: rgba(251, 243, 219, 1);
}
.highlight-teal_background {
	background: rgba(237, 243, 236, 1);
}
.highlight-blue_background {
	background: rgba(231, 243, 248, 1);
}
.highlight-purple_background {
	background: rgba(244, 240, 247, 0.8);
}
.highlight-pink_background {
	background: rgba(249, 238, 243, 0.8);
}
.highlight-red_background {
	background: rgba(253, 235, 236, 1);
}
.block-color-default {
	color: inherit;
	fill: inherit;
}
.block-color-gray {
	color: rgba(120, 119, 116, 1);
	fill: rgba(120, 119, 116, 1);
}
.block-color-brown {
	color: rgba(159, 107, 83, 1);
	fill: rgba(159, 107, 83, 1);
}
.block-color-orange {
	color: rgba(217, 115, 13, 1);
	fill: rgba(217, 115, 13, 1);
}
.block-color-yellow {
	color: rgba(203, 145, 47, 1);
	fill: rgba(203, 145, 47, 1);
}
.block-color-teal {
	color: rgba(68, 131, 97, 1);
	fill: rgba(68, 131, 97, 1);
}
.block-color-blue {
	color: rgba(51, 126, 169, 1);
	fill: rgba(51, 126, 169, 1);
}
.block-color-purple {
	color: rgba(144, 101, 176, 1);
	fill: rgba(144, 101, 176, 1);
}
.block-color-pink {
	color: rgba(193, 76, 138, 1);
	fill: rgba(193, 76, 138, 1);
}
.block-color-red {
	color: rgba(212, 76, 71, 1);
	fill: rgba(212, 76, 71, 1);
}
.block-color-gray_background {
	background: rgba(241, 241, 239, 1);
}
.block-color-brown_background {
	background: rgba(244, 238, 238, 1);
}
.block-color-orange_background {
	background: rgba(251, 236, 221, 1);
}
.block-color-yellow_background {
	background: rgba(251, 243, 219, 1);
}
.block-color-teal_background {
	background: rgba(237, 243, 236, 1);
}
.block-color-blue_background {
	background: rgba(231, 243, 248, 1);
}
.block-color-purple_background {
	background: rgba(244, 240, 247, 0.8);
}
.block-color-pink_background {
	background: rgba(249, 238, 243, 0.8);
}
.block-color-red_background {
	background: rgba(253, 235, 236, 1);
}
.select-value-color-pink { background-color: rgba(245, 224, 233, 1); }
.select-value-color-purple { background-color: rgba(232, 222, 238, 1); }
.select-value-color-green { background-color: rgba(219, 237, 219, 1); }
.select-value-color-gray { background-color: rgba(227, 226, 224, 1); }
.select-value-color-translucentGray { background-color: rgba(255, 255, 255, 0.0375); }
.select-value-color-orange { background-color: rgba(250, 222, 201, 1); }
.select-value-color-brown { background-color: rgba(238, 224, 218, 1); }
.select-value-color-red { background-color: rgba(255, 226, 221, 1); }
.select-value-color-yellow { background-color: rgba(253, 236, 200, 1); }
.select-value-color-blue { background-color: rgba(211, 229, 239, 1); }

.checkbox {
	display: inline-flex;
	vertical-align: text-bottom;
	width: 16;
	height: 16;
	background-size: 16px;
	margin-left: 2px;
	margin-right: 5px;
}

.checkbox-on {
	background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg-width%3D%2216%22-height%3D%2216%22-viewBox%3D%220-0-16-16%22-fill%3D%22none%22-xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%3Crect-width%3D%2216%22-height%3D%2216%22-fill%3D%22%2358A9D7%22%2F%3E%0A%3Cpath-d%3D%22M6.71429-12.2852L14-4.9995L12.7143-3.71436L6.71429-9.71378L3.28571-6.2831L2-7.57092L6.71429-12.2852Z%22-fill%3D%22white%22%2F%3E%0A%3C%2Fsvg%3E");
}

.checkbox-off {
	background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg-width%3D%2216%22-height%3D%2216%22-viewBox%3D%220-0-16-16%22-fill%3D%22none%22-xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%3Crect-x%3D%220.75%22-y%3D%220.75%22-width%3D%2214.5%22-height%3D%2214.5%22-fill%3D%22white%22-stroke%3D%22%2336352F%22-stroke-width%3D%221.5%22%2F%3E%0A%3C%2Fsvg%3E");
}
	

@media (max-width: 575.98px) {
	body {
		padding-left: 1rem;
		padding-right: 1rem;
		font-size: 2.0rem;
	}
	a {
		font-size: 2.0rem;
	}
	h1 {
		font-size: Fsrem;
	}
	h2 {
		font-size: 2.0rem;
	}
	h3 {
		font-size: 2.0rem;
	}
    p {
        font-size: 2.0rem;
    }
	img {
   		max-width: 90%;
  	  	min-width: 36px;
 	   	height: auto;
	}
}


@media (max-width: 767.98px) {
	body {
		padding-left: 1rem;
		padding-right: 1rem;
		font-size: 1.8rem;
	}
	a {
		font-size: 1.8rem;
	}
	h1 {
		font-size: Fsrem;
	}
	h2 {
		font-size: 1.8rem;
	}
	h3 {
		font-size: 1.8rem;
	}
    p {
        font-size: 1.8rem;
    }
	img {
   		max-width: 90%;
  	  	min-width: 36px;
 	   	height: auto;
	}
}


@media (max-width: 991.98px) {
	body {
		padding-left: 1rem;
		padding-right: 1rem;
		font-size: 1.7rem;
	}
	a {
		font-size: 1.7rem;
	}
	h1 {
		font-size: Fsrem;
	}
	h2 {
		font-size: 1.7rem;
	}
	h3 {
		font-size: 1.7rem;
	}
    p {
        font-size: 1.7rem;
    }
	img {
   		max-width: 90%;
  	  	min-width: 36px;
 	   	height: auto;
	}
}


@media (max-width: 1199.98px) {
	body {
		padding-left: 1rem;
		padding-right: 1rem;
		font-size: 1.6rem;
	}
	a {
		font-size: 1.6rem;
	}
	h1 {
		font-size: Fsrem;
	}
	h2 {
		font-size: 1.6rem;
	}
	h3 {
		font-size: 1.6rem;
	}
    p {
        font-size: 1.6rem;
    }
	img {
   		max-width: 90%;
  	  	min-width: 36px;
 	   	height: auto;
	}
}


@media (max-width: 1399.98px) {
	body {
		padding-left: 1rem;
		padding-right: 1rem;
		font-size: 1.4rem;
	}
	a {
		font-size: 1.4rem;
	}
	h1 {
		font-size: Fsrem;
	}
	h2 {
		font-size: 1.4rem;
	}
	h3 {
		font-size: 1.4rem;
	}
    p {
        font-size: 1.4rem;
    }
	img {
   		max-width: 90%;
  	  	min-width: 36px;
 	   	height: auto;
	}
}
</style></head><body><article id="408f6a11-b784-4b31-a1ae-14f76ae20204" class="page sans"><header><h1 class="page-title">Lab 1.1 Twitter Timeline</h1></header><div class="page-body"><div><p id="d623529e-b42e-4f3e-9faf-93b865c175cc" class="">Data Al Dente</p><p id="7f8dacda-5257-4c3b-86df-a683e1b85c55" class=""><a href="../../../index.html">Home</a> | <a href="../../Posts.html">Posts</a> | <a href="../../About-Me.html">About Me</a></p></div><p id="b15e1f4a-9b01-4024-826c-07a9d85de895" class="">Created <time>@April 5, 2023</time> </p><p id="1d28af4f-61be-4a31-baa2-de2885d14871" class="">Updated <time>@April 20, 2023</time> </p><ul id="518b45fb-e6e8-42df-a1e3-2d54883134d5" class="toggle"><li><details><summary style="cursor: pointer">Outline</summary><nav id="82a10be0-8879-494b-84fd-798b6592bcaa" class="block-color-gray table_of_contents"><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#fe038e15-9430-49be-8710-81f5cb70cbc9">Prerequisites</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#d171a26e-39b3-463d-9929-36148ccb9760">Setup</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#47ab4027-1e5d-46d2-a88a-159234ae525c">Verify Setup</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#aca35f58-d673-46db-bb6f-4995863972cb">Context/Gameplan</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#12963d3a-1528-4141-ad5c-1b135e7e17e6">Entities/Nouns/Data Model</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#9afb1ca5-682f-4192-94a3-067a4c420f14">Option 1: Timeline on Read</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#4100ab49-6442-43ae-9b3e-9863b86e64e9">Option 2: Timeline on Write</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#3c49bcd4-6eed-41dc-922d-0c3213befa5c">Comparing Timeline on Read vs Write</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#2f5ee4b3-c79b-437d-bc7e-d96a55c0f9f2">Benchmarking</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#2dd92ded-49e0-4d3a-b8d8-dbcb30c27d44">Conclusion</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#9685d1ac-f074-4a14-9a2b-fa2e58b85199">Misc</a></div></nav></details></li></ul><h1 id="fe038e15-9430-49be-8710-81f5cb70cbc9" class="">Prerequisites</h1><p id="3b94a843-d02e-473b-b4be-51214cc7c025" class="">You should read the Preface and Chapter 1 (Reliable, Scalable, and Maintainable Applications) of Designing Data-Intensive Applications before completing this lab. See the <a href="Introduction.html">Course Intro</a> for where you can purchase a copy.</p><h1 id="d171a26e-39b3-463d-9929-36148ccb9760" class="">Setup</h1><p id="a8838522-5338-4174-9677-0a3078c2bb1a" class=""><a href="https://docs.docker.com/engine/install/">Install Docker</a>.</p><p id="8f510858-ddb6-48ef-8cca-c166e8f2de32" class="">Ensure docker is running (you may need to open the Docker application)</p><p id="ad96cdcf-cb49-4629-b92c-36e1166e4632" class="">Note, if you’ve already got a recent version of sqlite installed and don’t want to use docker, then you could just run the shell command <code>sqlite3</code> instead of using docker for this lab.</p><h1 id="47ab4027-1e5d-46d2-a88a-159234ae525c" class="">Verify Setup</h1><p id="90eac99c-3b27-4bad-9ea1-a4bea6908a7d" class="">Each command should output the commented out lines directly below it:</p><pre id="fc018211-8aa2-4b0b-a998-5d30ec66a377" class="code code-wrap"><code>docker run --rm -it keinos/sqlite3
# SQLite version 3.A.B 2023-CC-DD EE:FF:GG
# Enter &quot;.help&quot; for usage hints.
# Connected to a transient in-memory database.
# Use &quot;.open FILENAME&quot; to reopen on a persistent database.
# sqlite&gt;

select 1 + 1;
# 2

# You can exit the sqlite prompt by typing CTRL-D. You can use CTRL-Z to
# put the sqlite3 prompt in the background and use fg to restore it.
# Same thing to exit the shell prompt.
# If you exit, any tables or data you&#x27;ve defined will be lost.</code></pre><h1 id="aca35f58-d673-46db-bb6f-4995863972cb" class="">Context/Gameplan</h1><p id="72f11f5a-2262-47c6-b552-476c55c8ae3e" class="">We’re going to implement a simplified version of the twitter timeline using SQLite. We’re going to try out two different ways of implementing the timeline and evaluate their tradeoffs.</p><p id="c8a2c4fb-b4c0-4c86-bca3-3baa00f97369" class="">Roughly, a Twitter timeline works like this:</p><p id="d05e9734-1f59-4748-a6d1-317bd53c422c" class="">A user U1 posts a tweet (a tweet for our purposes is just a string).</p><p id="2a41661d-8235-4cdc-88a1-a5fd10d8ede7" class="">A user U2 posts a tweet.</p><p id="4e07440e-14f1-4219-aedc-f863af70e03f" class="">A different user U3 loads their timeline.</p><p id="9aebf864-ce21-4f22-a026-6401b75d2a2d" class="">When user U3 loads their timeline, the tweets from all the users U3 follows are displayed sorted by time. If user U3 follows users U1 and U2, then their posted tweets will show up in user U3’s timeline.</p><p id="7774634f-622a-47d1-9016-b14e30d47c6d" class="">
</p><p id="9dcdc6af-9ba8-4915-9c67-801f63a078e2" class="">Note, we’re going to have the timeline sorted in time ascending order instead of descending order to keep things simpler, but of course in real life you’d do descending. Also, we’re not going to worry about keeping track of which tweets a user has already read, we’ll just show all the tweets in the timeline every time we load it.</p><h1 id="12963d3a-1528-4141-ad5c-1b135e7e17e6" class="">Entities/Nouns/Data Model</h1><p id="7aac5884-0ccc-4de2-89ac-f3ca45ee1856" class="">We’re going to start creating tables in SQLite for this lab, if you disconnected from your SQLite database, rerun this to reconnect. Don’t disconnect for the rest of this lab (or you’ll have to restart from here).</p><pre id="fbf8e91b-a40b-49be-a1b8-021caa843f79" class="code code-wrap"><code>docker run --rm -it keinos/sqlite3</code></pre><p id="688fc834-5f0d-49d4-9424-7d9baa05e428" class="">First, let’s think about what tables we should create. Try to come up with a data model to support the use case described above and then write the create table statements for it. Once you’ve done so, compare your solution with the one below.</p><p id="00474e4a-1206-4ef2-a21a-b3207f44482c" class=""><textarea style="width: 100%; font-family: monospace;" rows="5" placeholder="Enter text here (scratch space)"></textarea></p><ul id="5cf6c942-ff9b-401a-91c6-fb8ce9e4f1f9" class="toggle"><li><details><summary style="cursor: pointer">Solution</summary><p id="4585bd64-b133-454b-9245-22b1df372a4e" class="">The key entities/nouns here are:</p><p id="9d9461a5-0105-4611-9121-87da6d46ea65" class="">Users</p><p id="4220e829-8692-4926-8680-d978356278f5" class="">Tweets</p><p id="48a5d208-74f4-423c-9933-87cdb16834b2" class="">Follows</p><figure id="f9aa997f-3eeb-4770-911d-1bf6483b8429" class="image"><a href="Lab-1-1-Twitter-Timeline/Untitled.png"><img style="width:934px" src="Lab-1-1-Twitter-Timeline/Untitled.png"/></a></figure><p id="6f861ea4-15ea-4cce-b57e-4cbfcb6801b1" class=""><a href="https://whimsical.com/lab-0-1-entities-data-model-GVgogWwQiMcsU5roiByNjK">Source Diagram Link</a></p><p id="ebb29ca7-13d8-4be0-bf9c-87b4fe65df31" class="">Let’s create tables for users, tweets, and follows in our SQLite database.</p><div><pre id="e6b19b10-96a5-47bb-9618-65505b959fb6" class="code code-wrap"><code>create table users (
  id integer primary key,
  username text unique
);

create table tweets (
  id integer primary key,
  poster_id integer references users(id),
  content text,
  post_time integer
);

create table follows (
  follower_id integer references users(id),
  followee_id integer references users(id)
);</code></pre></div><p id="842bf0d4-b151-4626-987a-cb2ca4708b7a" class="">
</p><p id="7620b3a4-3f37-4f0e-b91c-d2428d9965ba" class="">Verify that the tables were created:</p><pre id="ea6a07bd-b9b4-4a52-a675-2bee9deeb31c" class="code code-wrap"><code>.tables
# follows  tweets   users</code></pre><p id="e896b4f3-3289-472b-986a-9106253b84e7" class="">Note that SQLite <a href="https://www.sqlite.org/foreignkeys.html">does not enforce foreign keys by default</a>, we could turn on foreign key enforcement but that would slightly complicate some of the code in this lab, so we’re not going to do so.</p></details></li></ul><p id="34a9a435-2b83-475a-b066-c625421c972c" class="">Let’s also turn on headers to make the query results easier to understand:</p><pre id="4b2b9729-5a2d-453c-bca8-bd07c259eca8" class="code code-wrap"><code># shows the table column names when we run select queries
.headers on</code></pre><p id="121527b6-2438-45fd-839d-09b2d4a1b751" class="">Ok, we’re ready to start implementing the timeline feature.</p><h1 id="9afb1ca5-682f-4192-94a3-067a4c420f14" class="">Option 1: Timeline on Read</h1><p id="439d5512-5739-48b1-a033-eb3b0aa4f3ff" class="">One way you could implement timelines is by writing a query which requests all the tweets from the users a given user follows sorted by time. We’re going to write that query. First, let’s add some simple dummy data for users and follows.</p><pre id="7a0085f5-3fcc-4d1b-9881-f097ccb13deb" class="code code-wrap"><code>insert into users (username) values (&#x27;alice&#x27;), (&#x27;bob&#x27;), (&#x27;charlie&#x27;), (&#x27;david&#x27;);

insert into follows select alice.id, bob.id from users alice, users bob where alice.username = &#x27;alice&#x27; and bob.username = &#x27;bob&#x27;;
insert into follows select alice.id, charlie.id from users alice, users charlie where alice.username = &#x27;alice&#x27; and charlie.username = &#x27;charlie&#x27;;</code></pre><p id="b7e490ba-5ce9-4f1e-a670-3f39338c494a" class="">What we’re done here is create 4 users with the usernames <code>alice</code>, <code>bob</code>, <code>charlie</code>, and <code>david</code> and then <code>alice</code> has started following <code>bob</code> and <code>charlie</code> (but not <code>david</code>).</p><p id="dc6d7be5-bf68-45c9-84ac-6c02724e35ef" class="">Let’s verify that our users and follows were inserted correctly (it’s ok if the id’s chosen by SQLite differ or the order of rows returned differs):</p><pre id="b3961a3e-78bc-4665-abba-f6d4a3681697" class="code code-wrap"><code>select * from users;
# id|username
# 1|alice
# 2|bob
# 3|charlie
# 4|david

select * from follows;
# follower_id|followee_id
# 1|2
# 1|3</code></pre><p id="02609c4c-41b3-4a73-b3ae-ee3bf53b3792" class="">Now we’re going to create some tweets.</p><pre id="df1380bb-5465-4162-8681-d02b2ed106dd" class="code code-wrap"><code>insert into tweets (poster_id, content, post_time) select alice.id, &#x27;alice first tweet&#x27;, 0 from users alice where alice.username = &#x27;alice&#x27;;

insert into tweets (poster_id, content, post_time) select bob.id, &#x27;bob first tweet&#x27;, 1 from users bob where bob.username = &#x27;bob&#x27;;

insert into tweets (poster_id, content, post_time) select charlie.id, &#x27;charlie first tweet&#x27;, 2 from users charlie where charlie.username = &#x27;charlie&#x27;;

insert into tweets (poster_id, content, post_time) select bob.id, &#x27;bob second tweet&#x27;, 3 from users bob where bob.username = &#x27;bob&#x27;;

insert into tweets (poster_id, content, post_time) select david.id, &#x27;david first tweet&#x27;, 4 from users david where david.username = &#x27;david&#x27;;</code></pre><p id="f4d8e1ef-ad29-4b81-82f3-645c72790859" class="">Note that we hardcoded the <code>post_time</code> for these tweets to be between 0 and 4.</p><p id="e25cccee-403b-4609-a7ff-17971e531eeb" class="">Let’s verify the tweets we inserted (we’re going to order the results by <code>post_time</code>):</p><pre id="6531f488-edb5-45d1-bda9-f34a3a028aca" class="code code-wrap"><code>select * from tweets order by post_time;
# id|poster_id|content|post_time
# 1|1|alice first tweet|0
# 2|2|bob first tweet|1
# 3|3|charlie first tweet|2
# 4|2|bob second tweet|3
# 5|4|david first tweet|4</code></pre><p id="84815360-8251-4c07-93f4-87c2252762fe" class="">We can see there are 5 tweets, 1 from <code>alice</code>, 2 from <code>bob</code>, 1 from <code>charlie</code>, and 1 from <code>david</code>. The order of tweets by <code>post_time</code> is:</p><p id="c8d4c022-44e9-45f7-964d-15c0eb29f210" class=""><code>alice</code>&#x27;s first tweet.</p><p id="0691fa0c-a280-4f48-b1c9-b0b8af3de2b1" class=""><code>bob</code>&#x27;s first tweet.</p><p id="789e77bc-cebd-46a0-957c-d0fbdf6885e3" class=""><code>charlie</code>&#x27;s first tweet.</p><p id="2771bb79-8ce4-44ca-afc6-123f783dd932" class=""><code>bob</code>&#x27;s second tweet.</p><p id="fa6f6db5-1248-4780-9a84-7898628db5a6" class=""><code>david</code>&#x27;s first tweet.</p><p id="f18bf120-b91c-4ced-b313-bc4829ffb69f" class="">Now it’s your turn to try to figure out how to write a query which does the following: Given a user ID, load all the tweets (id, poster_id, content, and post_time) for that users timeline sorted by the <code>post_time</code>. Remember that a user’s timeline should have all the tweets from that user’s “followees”.</p><p id="1691e1c7-19b9-4399-ad0e-8fbe9394eec1" class=""><textarea style="width: 100%; font-family: monospace;" rows="5" placeholder="Enter text here (scratch space)"></textarea></p><ul id="2b84b472-166f-4058-a08e-bb34070f9ca9" class="toggle"><li><details><summary style="cursor: pointer">Hint: Here’s an example query which shows how to get the user IDs for a users’s “followees”</summary><pre id="41a5f89b-e621-4251-948a-fadc37d93e95" class="code code-wrap"><code>select f.followee_id from users given_user join follows f on f.follower_id = given_user.id where given_user.username = &#x27;alice&#x27;;
# followee_id
# 2
# 3

# or if you prefer to use id instead of username
select f.followee_id from follows f where f.follower_id = 1;
# followee_id
# 2
# 3</code></pre></details></li></ul><ul id="6947b825-271b-46f2-8069-026dfb13d2d7" class="toggle"><li><details><summary style="cursor: pointer">Solution</summary><pre id="e37f50a1-4c20-4118-bdf7-5a5285fbb691" class="code code-wrap"><code>select t.* from users given_user join follows f on f.follower_id = given_user.id join tweets t on t.poster_id = f.followee_id where given_user.username = &#x27;alice&#x27; order by t.post_time;
# id|poster_id|content|post_time
# 2|2|bob first tweet|1
# 3|3|charlie first tweet|2
# 4|2|bob second tweet|3


# or if your prefer to use id instead of username
select t.* from follows f join tweets t on t.poster_id = f.followee_id where f.follower_id = 1 order by t.post_time;
# id|poster_id|content|post_time
# 2|2|bob first tweet|1
# 3|3|charlie first tweet|2
# 4|2|bob second tweet|3</code></pre></details></li></ul><p id="20592d23-88d6-4947-9f28-28bb1c4a160b" class="">Do you think this design for implementing timelines is a good solution? Is it performant? Is it scalable? Is it reliable?</p><p id="a8eb5940-0c46-4ed1-97af-436402f30ea9" class=""><textarea style="width: 100%; font-family: monospace;" rows="5" placeholder="Enter text here (scratch space)"></textarea></p><ul id="de7c32ff-b53c-4219-a117-dba36dae64ed" class="toggle"><li><details><summary style="cursor: pointer">Solution</summary><p id="eabd6aee-185d-4266-8baf-2356c9ea1799" class="">The “correct” answer to this question is, “it depends.” And it turns out that “it depends” is almost always the correct answer when starting to evaluate any design. In other words, asking if a system design is “good” without more details is not a reasonable question to ask given the information you have so far. We’ll talk more about this later and throughout this course, but it’s crucial to remember that every design makes tradeoffs and those tradeoffs are based on assumptions about how the system will be used. Is it write-heavy or read-heavy? How much downtime is acceptable? Who are the users and administrators? What types of reads and writes should be supported? How long of response time is acceptable? etc, etc, etc. I’ll have some examples of more well founded questions later, but I want to point out that it’s not useful to design a system in a vacuum, you should design based on the tradeoffs and assumptions you want built into the system.</p><p id="adfb0fdc-a245-4970-b807-1876a3943e75" class="">If you’re like me, when you first thought about this question, you thought some things like, “well it’s using SQLite so that means it will only run on a single instance, so it can be scaled vertically but not horizontally and SQLite only supports a single writer at a time” and “the query as written will be slow as the number of tweets and follows grows because it has to look up all the necessary tweets and sort them each time you run it”. These are (I think), reasonable things to think, but I’m trying to make the point that all designs must be built around the problem they’re trying to solve and there is no one size fits all magic solution which is always the right call. For example, if you’re writing an embedded system which needs to store relational data locally, then SQLite may be a good choice. However, if you need highly scalable relational data storage with high writes per second for a worldwide internet-based system, then SQLite may not the right choice of database.</p></details></li></ul><p id="110756dc-d75d-4dbc-bfcb-98237c038863" class="">To get a better handle on these kinds of questions, we’re going to discuss another approach to how you could handle timelines and then follow up by comparing and contrasting their reliability, scalability, and maintainability in a more concrete way.</p><h1 id="4100ab49-6442-43ae-9b3e-9863b86e64e9" class="">Option 2: Timeline on Write</h1><p id="8da18ace-761f-4dee-83e1-e36bc763b6af" class="">We’re going to try a different way to implement timelines. In this method, we’ll keep a timeline for each user and every time a tweet is posted, then we’ll append that tweet to all the the timelines of all the followers of the user who posted the tweet.</p><p id="15d3d1b3-ba63-4d6e-b78f-d12efc21e675" class="">First, let’s create a timelines table.</p><p id="f1d6916a-b10c-4439-b653-5cab2504d9d3" class="">Side note, we’re going to do something a little weird here, which is to use a JSON array in SQLite for each user’s timeline. This probably isn’t the best way to do this, but I think it will be sufficient for this demonstration. Also, I’m using username instead of user ID here because it simplifies the queries below.</p><div><pre id="a6a52b95-3317-4eb8-83c6-82f5da1e1ea3" class="code code-wrap"><code>create table timelines (username text unique references users(username), timeline_json text);</code></pre></div><p id="d504f5e8-23d7-4d37-a27c-1b4d63f548d8" class="">Let’s insert the tweets from our tweets table into this timelines table to show how it works. Note that the code below is pretty hacky and you’d probably do something better than this in real life. We’re essentially using the timelines table as a key value store where the key is the user ID and the value is a JSON array of the user’s timeline.</p><pre id="4ca74d4b-db03-4fdb-8691-d33a2c8dfa46" class="code code-wrap"><code># create an empty array for each user&#x27;s id.
insert into timelines select username, json_array() from users;

# now each user has an empty JSON array for their timeline
select * from timelines;
# username|timeline_json
# alice|[]
# bob|[]
# charlie|[]
# david|[]

# alice is the only user who has followed anyone at this point, so let&#x27;s
# insert the tweets from her followees into alice&#x27;s timeline. Note that the
# order matters here since we&#x27;re appending to an array
update timelines set timeline_json = json_insert(timeline_json, &#x27;$[#]&#x27;, json_object(&#x27;tweet_id&#x27;, tweets.id, &#x27;poster_id&#x27;, tweets.poster_id, &#x27;content&#x27;, tweets.content, &#x27;post_time&#x27;, tweets.post_time)) from (select tweets.*, users.username poster_username from tweets join users on users.id = tweets.poster_id where content = &#x27;bob first tweet&#x27;) tweets where username = &#x27;alice&#x27;;

update timelines set timeline_json = json_insert(timeline_json, &#x27;$[#]&#x27;, json_object(&#x27;tweet_id&#x27;, tweets.id, &#x27;poster_id&#x27;, tweets.poster_id, &#x27;content&#x27;, tweets.content, &#x27;post_time&#x27;, tweets.post_time)) from (select tweets.*, users.username poster_username from tweets join users on users.id = tweets.poster_id where content = &#x27;charlie first tweet&#x27;) tweets where username = &#x27;alice&#x27;;

update timelines set timeline_json = json_insert(timeline_json, &#x27;$[#]&#x27;, json_object(&#x27;tweet_id&#x27;, tweets.id, &#x27;poster_id&#x27;, tweets.poster_id, &#x27;content&#x27;, tweets.content, &#x27;post_time&#x27;, tweets.post_time)) from (select tweets.*, users.username poster_username from tweets join users on users.id = tweets.poster_id where content = &#x27;bob second tweet&#x27;) tweets where username = &#x27;alice&#x27;;

# now if we look at the timelines, we&#x27;ll see that alice&#x27;s is populated with
# the expected tweets
select * from timelines;</code></pre><p id="e13469a3-f4d6-4115-a2f8-20be0dccfd0f" class="">Now we can load up Alice’s timeline using the timelines table like this:</p><pre id="371fbeed-e340-4972-b638-06a1c84e177e" class="code code-wrap"><code># load as JSON
select timeline_json from timelines where username = &#x27;alice&#x27;;

# load as rows (using json-each function with a join)
select je.value from timelines, json_each(timelines.timeline_json) je where username = &#x27;alice&#x27;;</code></pre><p id="69314f01-ef59-409b-8d7e-5c5625c1c83b" class="">Note that in the example I’m assuming <code>json_each</code> returns the rows in order, I’m just doing this to make it simpler but in real life you’d want to handle that.</p><h1 id="3c49bcd4-6eed-41dc-922d-0c3213befa5c" class="">Comparing Timeline on Read vs Write</h1><p id="f7e792ea-c9cc-47bd-9891-297e09bb2e45" class="">Now we have two options for how to implement timelines, we can either compute them on read using timeline on read (option 1) or we can compute them on write using timeline on write (option 2).</p><p id="7a999581-13b1-497a-aa1a-359c5795f775" class="">I want to make sure we’re clear on exactly how these two options work, can you describe the process and steps for reading and writing for each option?</p><p id="b9fa56b1-a36a-44b3-9ca7-11fa0b3f518a" class=""><textarea style="width: 100%; font-family: monospace;" rows="5" placeholder="Enter text here (scratch space)"></textarea></p><ul id="0b012752-7618-4559-b4e3-d14e7bd42732" class="toggle"><li><details><summary style="cursor: pointer">Solution</summary><p id="2b061c04-ed63-4db8-846f-583a526d389b" class="">In timeline on read (option 1), whenever a user posts a tweet, that tweet is inserted into the tweets table. Whenever a user loads their timeline, then the query to load the timeline searches over the entire tweets table, finds the tweets of the user’s followees, and sorts them by time. Therefore with this option posting tweets is not very much work for the database, but loading the timeline is lots of work for the database.</p><p id="38c699eb-dbd2-4484-8609-3ca842e4b86a" class="">In timeline on write (option 2), whenever a user posts a tweet, that tweet is still inserted into the tweets table, but it is also inserted into every followee’s timeline. Then, instead of loading the timeline for a user from the tweets table, it can simply be loaded from the timelines table. Therefore with this option posting tweets can be a lot of work for the database (depending on how many followers a poster has), but loading the timeline is not not much work for the database.</p></details></li></ul><p id="4987ebec-e8f8-4f63-9660-2ab1c4f21e19" class="">Let’s talk about which option is “better”.</p><p id="3643d9c5-ab3e-4cd0-b26d-72736c20c572" class="">Hopefully you remember our recent discussion about “it depends” and so when I said let’s talk about which one is better, you thought to yourself, “it depends”. But what does it depend on? Let’s examine a few tradeoffs between the two approaches.</p><p id="11b17073-ee26-4429-8fe7-0ee7382a592e" class="">Which option do you expect to be faster for reads (e.g.: loading a timeline)? Why?</p><p id="75710b5d-2f14-4ae4-9353-5435f1b3c0de" class=""><textarea style="width: 100%; font-family: monospace;" rows="5" placeholder="Enter text here (scratch space)"></textarea></p><ul id="be0e50e6-6f3d-4041-b26d-8877dc77a9f1" class="toggle"><li><details><summary style="cursor: pointer">Solution</summary><p id="25f9aedf-8cf6-4fe8-8ef9-370b817a25e9" class="">Timeline on write (option 2) should be faster for reads since it “precomputes” the timeline. This means that returning the timeline is essentially just a key-value look up by username, which should be quite fast. In timeline on read (option 1), the database has to compute a join across multiple tables and then order the results by time, which could be slow depending on how much data exists.</p></details></li></ul><p id="a22bf73f-0a57-459b-883f-3a5edbb45f83" class="">Which option do you expect to be faster for writes (e.g.: posting a tweet)? Why?</p><p id="7a3bbeb8-d8be-4547-93f9-344b963e5b16" class=""><textarea style="width: 100%; font-family: monospace;" rows="5" placeholder="Enter text here (scratch space)"></textarea></p><ul id="3350af8c-d0a9-47a6-ba1c-4b0c9c1127cb" class="toggle"><li><details><summary style="cursor: pointer">Solution</summary><p id="b8bddcab-d910-4285-a280-39a36a4ce662" class="">Timeline on read (option 1) should be faster for writes since the only write required is inserting one new row into the tweets table, which should be fast. In timeline on write (option 2), the database still inserts the row into the tweets table but also has to insert into the timeline of every single follower of the user who posted the tweet, which could be slow depending on the number of followers.</p></details></li></ul><p id="ec498e2a-76bb-4fa1-ae49-fb1bd55d4c7f" class="">How does the number of followers and followees affect the performance of each option?</p><p id="273a89b0-988d-4b30-a2e0-048996ec3fb2" class=""><textarea style="width: 100%; font-family: monospace;" rows="5" placeholder="Enter text here (scratch space)"></textarea></p><ul id="386f6bd5-7630-41ad-ad84-c3a4d9a36006" class="toggle"><li><details><summary style="cursor: pointer">Solution</summary><p id="dda2098b-b151-41ca-8449-11d1c7a43bad" class="">The more followers and followees a user has, the more “fan-out” occurs (e.g.: timelines require more work for users with more followers). This parameter affects both options. In timeline on read (option 1), more followers means that we’ll have to return more tweets in the timeline (and therefore load more of the tweets table, even if it’s well indexed). In timeline on write (option 2), more followers means that we’ll have to write to more timelines.</p><p id="bce16d1f-3b28-4a45-a386-f34bcd18ab11" class="">
</p></details></li></ul><p id="c4ac50f5-e4c1-4006-bea3-2f6d10e691e7" class="">Which option uses more storage space? Roughly how much more?</p><p id="f3f0e42b-829b-4e86-8416-4ad4f2674881" class=""><textarea style="width: 100%; font-family: monospace;" rows="5" placeholder="Enter text here (scratch space)"></textarea></p><ul id="cc42ab50-d29e-46ea-a382-c398e89493d7" class="toggle"><li><details><summary style="cursor: pointer">Solution</summary><p id="290c0696-3260-4ac4-8e99-2c6a1c8eb475" class="">Timeline on read (option 1) will use much less storage space than timeline on write (option 2) because option 1 only stores tweets once. In option 2, tweets are copied for every follower when a tweet is posted. If we use option 2, we should make sure we are ok with how much storage space it’s going to use.</p></details></li></ul><p id="32576abd-d4be-42e6-be4a-a7815b5e980f" class="">Which option is more maintainable (this question is a bit fuzzy and hard to define, but thinking through maintainability is a good exercise and is important)?</p><p id="ee18721b-8e6d-4bb0-a832-633317c820cd" class=""><textarea style="width: 100%; font-family: monospace;" rows="5" placeholder="Enter text here (scratch space)"></textarea></p><ul id="0268ae04-0ca4-4a35-8b2b-db8edf57860d" class="toggle"><li><details><summary style="cursor: pointer">Solution</summary><p id="6f812a92-33a8-43db-adbd-d69a31017dd0" class="">Which option is more maintainable? There are two aspects of maintainability I want to address here (going to focus primarily on simplicity and evolvability). I think timeline on read (option 1) is simpler than timeline on write (option 2). Option 2 is complex for a few reasons.</p><p id="e47f352d-dda8-46c8-ae0a-5a189b574439" class="">Timeline on write (option 2) requires keeping multiple inserts across multiple tables in sync each time a tweet is posted. This means developers have to be careful when making changes to the code which inserts tweets. For example, do you need to transactionally update every single users’ timeline each time you add a tweet? This could be quite slow and slow down other queries on the database. Alternatively, if you do not insert all rows transactionally, then you may need to handle partial failures when a tweet is written only to some subset of the timelines. However, one way that I option 2 is that it gives a simple abstraction for developers reading timelines, they just select the relevant row from the timelines table. This is simpler than the more complex timeline query in option 1, however I think maintaining a single SQL query is much easier than maintaining the more complex logic keeping multiple table in sync.</p></details></li></ul><p id="078a00ec-dbe8-4127-8e92-89d359940322" class="">How does each option handle deletion or editing of tweets?</p><p id="cae5e872-2d7c-44ed-bcae-d23e86d59a72" class=""><textarea style="width: 100%; font-family: monospace;" rows="5" placeholder="Enter text here (scratch space)"></textarea></p><ul id="fa68f186-a589-4d97-87d6-04b7a52941c5" class="toggle"><li><details><summary style="cursor: pointer">Solution</summary><p id="45029ed6-5923-4f28-8d2c-7cce67b2cbb4" class="">In timeline on read (option 1), if a tweet is deleted or updated then you simply have to delete or update the corresponding tweet row in the tweets table. In timeline on write (option 2), you would need to delete or update the tweet in all the timelines in which it is stored. Given how potentially slow and non-performant this would be, you’d probably need to explore other ways of handling deletion and updating (e.g.: keep a separate cache with the ID’s of deleted or updated tweets and all users loading timeline must filter our deleting tweets or reload edited ones based on the cache).</p></details></li></ul><p id="b25c2377-c3e1-4862-baa8-41cf80e0cb95" class="">Which option uses a schemaless (e.g.: schema-on-read) approach? What are the tradeoffs associated with such an approach?</p><p id="0177cb43-2802-45d7-a8a4-4b72ffc774ac" class=""><textarea style="width: 100%; font-family: monospace;" rows="5" placeholder="Enter text here (scratch space)"></textarea></p><ul id="b111ff13-9e4d-43f2-b624-8ab52f94dc80" class="toggle"><li><details><summary style="cursor: pointer">Solution</summary><p id="849a2b48-af4e-44ff-80c9-6078e1064d66" class="">Timeline on write (option 2) uses a schema-on-read (schemaless) approach for the timeline. Because tweets are stored simply as JSON, there is no guarantee from the database about what fields exist in the JSON or what types those fields have. This means that whenever the fields on a tweet are updated then the code which reads the JSON timeline cannot generally assume that those fields exist on all tweets, therefore it must parse and verify the schema while reading the JSON. This is opposed to schema-on-write where all fields are guaranteed to exist and have a type (e.g.: a normal SQLite table). Given that we’re also storing tweets as a separate table, I think keeping that separate table and the timelines objects in sync results in more difficult maintenability.</p></details></li></ul><p id="864e2ccf-c098-47e5-bebd-5d58441a414c" class="">Given this discussion above, I would likely use timeline on read (option 1) if writes outnumber reads or if they occur at roughly the same frequency (or if we care more about write latency than read latency). However, if there are significantly more reads than writes, I would consider using timeline on write (option 2). Let’s try to do some quick benchmarking to see if we can get a more concrete idea of read vs write performance.</p><h1 id="2f5ee4b3-c79b-437d-bc7e-d96a55c0f9f2" class="">Benchmarking</h1><p id="e8974f9e-e1be-48a9-b084-d84e3e86e6a5" class="">We’re going to insert a bunch of dummy data and see if we can get enough data loaded to see a measurable difference between how long reads and writes take. To do so, we’re going to create some files with SQL statements inside the docker image and run them.</p><p id="f1804074-abda-4a1c-b1d1-6209e9b01dc8" class="">Start up docker and go to the home directory.</p><pre id="abe1f2c5-bea1-4f3a-943c-04b80d42f765" class="code"><code># If you&#x27;re just using sqlite3 directly instead of docker, skip this command
docker run --rm -it --entrypoint sh keinos/sqlite3

# Set the current directory to the user home dir
cd</code></pre><p id="a3dd9dec-17b9-4b96-a6a4-7b5cd1d8b967" class="">We’re going to save 4 queries to files to make it easier to benchmark them. Note that the last query is hidden inside a toggle (with the text “Toggle Query HERE”), make sure to expand that toggle and copy the shell command. The toggle query is quite large, so I figured it would be better to have it hidden by default.</p><p id="b81a3bf4-bc1e-4776-8496-44d1a331ed8c" class="">Run the following commands from inside the docker container in the home directory (or in whatever directory you wish if you’re not using docker):</p><pre id="6c36ec9a-55c9-4065-8e1d-096e7191fa91" class="code"><code>cat &lt;&lt;EOF &gt; load_timeline_on_read.sql
select t.*
from users
join follows f on f.follower_id = users.id
join tweets t on t.poster_id = f.followee_id
where users.id in (select id from users limit 1)
order by t.post_time
limit 10;
EOF</code></pre><pre id="2c4369ed-6530-4056-9922-d00bc67856b5" class="code"><code>cat &lt;&lt;EOF &gt; load_timeline_on_write.sql
select
timelines.username,
timelines.timeline_json -&gt; 0,
timeline_json -&gt; 1, 
timeline_json -&gt; 2, 
timeline_json -&gt; 3, 
timeline_json -&gt; 4, 
timeline_json -&gt; 5, 
timeline_json -&gt; 6, 
timeline_json -&gt; 7, 
timeline_json -&gt; 8, 
timeline_json -&gt; 9
from timelines
where timelines.username in (select username from users limit 1);
EOF</code></pre><pre id="2d37fb3c-a369-4af6-ab8f-6ce6a90b153d" class="code"><code>cat &lt;&lt;EOF &gt; insert_timeline_on_read.sql
begin transaction;

drop table if exists start_time;
create temp table start_time as SELECT CAST((julianday(&#x27;now&#x27;) - 2440587.5)*86400000 AS INTEGER) t;

insert into tweets (poster_id, content, post_time) values (1, cast(abs(random()) as text) || &#x27; moar content&#x27;, abs(random() % 1680750000));

select &#x27;*** END TIME&#x27;, round(((julianday(&#x27;now&#x27;) - 2440587.5)*86400000.0 - start_time.t) / 1000.0, 3) time_ms from start_time;

commit;
EOF</code></pre><ul id="7583adae-c661-4f71-85d2-30992ae4fc32" class="toggle"><li><details><summary style="cursor: pointer">This last </summary><pre id="387a032d-bf42-49e1-a643-456dd9a98d0d" class="code"><code>cat &lt;&lt;EOF &gt; insert_timeline_on_write.sql
begin transaction;

drop table if exists start_time;
create temp table start_time as SELECT CAST((julianday(&#x27;now&#x27;) - 2440587.5)*86400000 AS INTEGER) t;

update timelines set timeline_json = json_insert(timeline_json, &#x27;$[#]&#x27;, json_object(&#x27;tweet_id&#x27;, abs(random() % 2000000), &#x27;poster_id&#x27;, abs(random() % 2000), &#x27;content&#x27;, cast(abs(random()) as text) || &#x27;more content&#x27;, &#x27;post_time&#x27;, abs(random() % 1680750000))) from generate_series(1, 1) where username in (select username from users order by random() limit 1);

update timelines set timeline_json = json_insert(timeline_json, &#x27;$[#]&#x27;, json_object(&#x27;tweet_id&#x27;, abs(random() % 2000000), &#x27;poster_id&#x27;, abs(random() % 2000), &#x27;content&#x27;, cast(abs(random()) as text) || &#x27;more content&#x27;, &#x27;post_time&#x27;, abs(random() % 1680750000))) from generate_series(1, 1) where username in (select username from users order by random() limit 1);

update timelines set timeline_json = json_insert(timeline_json, &#x27;$[#]&#x27;, json_object(&#x27;tweet_id&#x27;, abs(random() % 2000000), &#x27;poster_id&#x27;, abs(random() % 2000), &#x27;content&#x27;, cast(abs(random()) as text) || &#x27;more content&#x27;, &#x27;post_time&#x27;, abs(random() % 1680750000))) from generate_series(1, 1) where username in (select username from users order by random() limit 1);

update timelines set timeline_json = json_insert(timeline_json, &#x27;$[#]&#x27;, json_object(&#x27;tweet_id&#x27;, abs(random() % 2000000), &#x27;poster_id&#x27;, abs(random() % 2000), &#x27;content&#x27;, cast(abs(random()) as text) || &#x27;more content&#x27;, &#x27;post_time&#x27;, abs(random() % 1680750000))) from generate_series(1, 1) where username in (select username from users order by random() limit 1);

update timelines set timeline_json = json_insert(timeline_json, &#x27;$[#]&#x27;, json_object(&#x27;tweet_id&#x27;, abs(random() % 2000000), &#x27;poster_id&#x27;, abs(random() % 2000), &#x27;content&#x27;, cast(abs(random()) as text) || &#x27;more content&#x27;, &#x27;post_time&#x27;, abs(random() % 1680750000))) from generate_series(1, 1) where username in (select username from users order by random() limit 1);

update timelines set timeline_json = json_insert(timeline_json, &#x27;$[#]&#x27;, json_object(&#x27;tweet_id&#x27;, abs(random() % 2000000), &#x27;poster_id&#x27;, abs(random() % 2000), &#x27;content&#x27;, cast(abs(random()) as text) || &#x27;more content&#x27;, &#x27;post_time&#x27;, abs(random() % 1680750000))) from generate_series(1, 1) where username in (select username from users order by random() limit 1);

update timelines set timeline_json = json_insert(timeline_json, &#x27;$[#]&#x27;, json_object(&#x27;tweet_id&#x27;, abs(random() % 2000000), &#x27;poster_id&#x27;, abs(random() % 2000), &#x27;content&#x27;, cast(abs(random()) as text) || &#x27;more content&#x27;, &#x27;post_time&#x27;, abs(random() % 1680750000))) from generate_series(1, 1) where username in (select username from users order by random() limit 1);

update timelines set timeline_json = json_insert(timeline_json, &#x27;$[#]&#x27;, json_object(&#x27;tweet_id&#x27;, abs(random() % 2000000), &#x27;poster_id&#x27;, abs(random() % 2000), &#x27;content&#x27;, cast(abs(random()) as text) || &#x27;more content&#x27;, &#x27;post_time&#x27;, abs(random() % 1680750000))) from generate_series(1, 1) where username in (select username from users order by random() limit 1);

update timelines set timeline_json = json_insert(timeline_json, &#x27;$[#]&#x27;, json_object(&#x27;tweet_id&#x27;, abs(random() % 2000000), &#x27;poster_id&#x27;, abs(random() % 2000), &#x27;content&#x27;, cast(abs(random()) as text) || &#x27;more content&#x27;, &#x27;post_time&#x27;, abs(random() % 1680750000))) from generate_series(1, 1) where username in (select username from users order by random() limit 1);

update timelines set timeline_json = json_insert(timeline_json, &#x27;$[#]&#x27;, json_object(&#x27;tweet_id&#x27;, abs(random() % 2000000), &#x27;poster_id&#x27;, abs(random() % 2000), &#x27;content&#x27;, cast(abs(random()) as text) || &#x27;more content&#x27;, &#x27;post_time&#x27;, abs(random() % 1680750000))) from generate_series(1, 1) where username in (select username from users order by random() limit 1);

update timelines set timeline_json = json_insert(timeline_json, &#x27;$[#]&#x27;, json_object(&#x27;tweet_id&#x27;, abs(random() % 2000000), &#x27;poster_id&#x27;, abs(random() % 2000), &#x27;content&#x27;, cast(abs(random()) as text) || &#x27;more content&#x27;, &#x27;post_time&#x27;, abs(random() % 1680750000))) from generate_series(1, 1) where username in (select username from users order by random() limit 1);

update timelines set timeline_json = json_insert(timeline_json, &#x27;$[#]&#x27;, json_object(&#x27;tweet_id&#x27;, abs(random() % 2000000), &#x27;poster_id&#x27;, abs(random() % 2000), &#x27;content&#x27;, cast(abs(random()) as text) || &#x27;more content&#x27;, &#x27;post_time&#x27;, abs(random() % 1680750000))) from generate_series(1, 1) where username in (select username from users order by random() limit 1);

update timelines set timeline_json = json_insert(timeline_json, &#x27;$[#]&#x27;, json_object(&#x27;tweet_id&#x27;, abs(random() % 2000000), &#x27;poster_id&#x27;, abs(random() % 2000), &#x27;content&#x27;, cast(abs(random()) as text) || &#x27;more content&#x27;, &#x27;post_time&#x27;, abs(random() % 1680750000))) from generate_series(1, 1) where username in (select username from users order by random() limit 1);

update timelines set timeline_json = json_insert(timeline_json, &#x27;$[#]&#x27;, json_object(&#x27;tweet_id&#x27;, abs(random() % 2000000), &#x27;poster_id&#x27;, abs(random() % 2000), &#x27;content&#x27;, cast(abs(random()) as text) || &#x27;more content&#x27;, &#x27;post_time&#x27;, abs(random() % 1680750000))) from generate_series(1, 1) where username in (select username from users order by random() limit 1);

update timelines set timeline_json = json_insert(timeline_json, &#x27;$[#]&#x27;, json_object(&#x27;tweet_id&#x27;, abs(random() % 2000000), &#x27;poster_id&#x27;, abs(random() % 2000), &#x27;content&#x27;, cast(abs(random()) as text) || &#x27;more content&#x27;, &#x27;post_time&#x27;, abs(random() % 1680750000))) from generate_series(1, 1) where username in (select username from users order by random() limit 1);

update timelines set timeline_json = json_insert(timeline_json, &#x27;$[#]&#x27;, json_object(&#x27;tweet_id&#x27;, abs(random() % 2000000), &#x27;poster_id&#x27;, abs(random() % 2000), &#x27;content&#x27;, cast(abs(random()) as text) || &#x27;more content&#x27;, &#x27;post_time&#x27;, abs(random() % 1680750000))) from generate_series(1, 1) where username in (select username from users order by random() limit 1);

update timelines set timeline_json = json_insert(timeline_json, &#x27;$[#]&#x27;, json_object(&#x27;tweet_id&#x27;, abs(random() % 2000000), &#x27;poster_id&#x27;, abs(random() % 2000), &#x27;content&#x27;, cast(abs(random()) as text) || &#x27;more content&#x27;, &#x27;post_time&#x27;, abs(random() % 1680750000))) from generate_series(1, 1) where username in (select username from users order by random() limit 1);

update timelines set timeline_json = json_insert(timeline_json, &#x27;$[#]&#x27;, json_object(&#x27;tweet_id&#x27;, abs(random() % 2000000), &#x27;poster_id&#x27;, abs(random() % 2000), &#x27;content&#x27;, cast(abs(random()) as text) || &#x27;more content&#x27;, &#x27;post_time&#x27;, abs(random() % 1680750000))) from generate_series(1, 1) where username in (select username from users order by random() limit 1);

update timelines set timeline_json = json_insert(timeline_json, &#x27;$[#]&#x27;, json_object(&#x27;tweet_id&#x27;, abs(random() % 2000000), &#x27;poster_id&#x27;, abs(random() % 2000), &#x27;content&#x27;, cast(abs(random()) as text) || &#x27;more content&#x27;, &#x27;post_time&#x27;, abs(random() % 1680750000))) from generate_series(1, 1) where username in (select username from users order by random() limit 1);

update timelines set timeline_json = json_insert(timeline_json, &#x27;$[#]&#x27;, json_object(&#x27;tweet_id&#x27;, abs(random() % 2000000), &#x27;poster_id&#x27;, abs(random() % 2000), &#x27;content&#x27;, cast(abs(random()) as text) || &#x27;more content&#x27;, &#x27;post_time&#x27;, abs(random() % 1680750000))) from generate_series(1, 1) where username in (select username from users order by random() limit 1);

update timelines set timeline_json = json_insert(timeline_json, &#x27;$[#]&#x27;, json_object(&#x27;tweet_id&#x27;, abs(random() % 2000000), &#x27;poster_id&#x27;, abs(random() % 2000), &#x27;content&#x27;, cast(abs(random()) as text) || &#x27;more content&#x27;, &#x27;post_time&#x27;, abs(random() % 1680750000))) from generate_series(1, 1) where username in (select username from users order by random() limit 1);

update timelines set timeline_json = json_insert(timeline_json, &#x27;$[#]&#x27;, json_object(&#x27;tweet_id&#x27;, abs(random() % 2000000), &#x27;poster_id&#x27;, abs(random() % 2000), &#x27;content&#x27;, cast(abs(random()) as text) || &#x27;more content&#x27;, &#x27;post_time&#x27;, abs(random() % 1680750000))) from generate_series(1, 1) where username in (select username from users order by random() limit 1);

update timelines set timeline_json = json_insert(timeline_json, &#x27;$[#]&#x27;, json_object(&#x27;tweet_id&#x27;, abs(random() % 2000000), &#x27;poster_id&#x27;, abs(random() % 2000), &#x27;content&#x27;, cast(abs(random()) as text) || &#x27;more content&#x27;, &#x27;post_time&#x27;, abs(random() % 1680750000))) from generate_series(1, 1) where username in (select username from users order by random() limit 1);

update timelines set timeline_json = json_insert(timeline_json, &#x27;$[#]&#x27;, json_object(&#x27;tweet_id&#x27;, abs(random() % 2000000), &#x27;poster_id&#x27;, abs(random() % 2000), &#x27;content&#x27;, cast(abs(random()) as text) || &#x27;more content&#x27;, &#x27;post_time&#x27;, abs(random() % 1680750000))) from generate_series(1, 1) where username in (select username from users order by random() limit 1);

update timelines set timeline_json = json_insert(timeline_json, &#x27;$[#]&#x27;, json_object(&#x27;tweet_id&#x27;, abs(random() % 2000000), &#x27;poster_id&#x27;, abs(random() % 2000), &#x27;content&#x27;, cast(abs(random()) as text) || &#x27;more content&#x27;, &#x27;post_time&#x27;, abs(random() % 1680750000))) from generate_series(1, 1) where username in (select username from users order by random() limit 1);

update timelines set timeline_json = json_insert(timeline_json, &#x27;$[#]&#x27;, json_object(&#x27;tweet_id&#x27;, abs(random() % 2000000), &#x27;poster_id&#x27;, abs(random() % 2000), &#x27;content&#x27;, cast(abs(random()) as text) || &#x27;more content&#x27;, &#x27;post_time&#x27;, abs(random() % 1680750000))) from generate_series(1, 1) where username in (select username from users order by random() limit 1);

update timelines set timeline_json = json_insert(timeline_json, &#x27;$[#]&#x27;, json_object(&#x27;tweet_id&#x27;, abs(random() % 2000000), &#x27;poster_id&#x27;, abs(random() % 2000), &#x27;content&#x27;, cast(abs(random()) as text) || &#x27;more content&#x27;, &#x27;post_time&#x27;, abs(random() % 1680750000))) from generate_series(1, 1) where username in (select username from users order by random() limit 1);

update timelines set timeline_json = json_insert(timeline_json, &#x27;$[#]&#x27;, json_object(&#x27;tweet_id&#x27;, abs(random() % 2000000), &#x27;poster_id&#x27;, abs(random() % 2000), &#x27;content&#x27;, cast(abs(random()) as text) || &#x27;more content&#x27;, &#x27;post_time&#x27;, abs(random() % 1680750000))) from generate_series(1, 1) where username in (select username from users order by random() limit 1);

update timelines set timeline_json = json_insert(timeline_json, &#x27;$[#]&#x27;, json_object(&#x27;tweet_id&#x27;, abs(random() % 2000000), &#x27;poster_id&#x27;, abs(random() % 2000), &#x27;content&#x27;, cast(abs(random()) as text) || &#x27;more content&#x27;, &#x27;post_time&#x27;, abs(random() % 1680750000))) from generate_series(1, 1) where username in (select username from users order by random() limit 1);

update timelines set timeline_json = json_insert(timeline_json, &#x27;$[#]&#x27;, json_object(&#x27;tweet_id&#x27;, abs(random() % 2000000), &#x27;poster_id&#x27;, abs(random() % 2000), &#x27;content&#x27;, cast(abs(random()) as text) || &#x27;more content&#x27;, &#x27;post_time&#x27;, abs(random() % 1680750000))) from generate_series(1, 1) where username in (select username from users order by random() limit 1);

update timelines set timeline_json = json_insert(timeline_json, &#x27;$[#]&#x27;, json_object(&#x27;tweet_id&#x27;, abs(random() % 2000000), &#x27;poster_id&#x27;, abs(random() % 2000), &#x27;content&#x27;, cast(abs(random()) as text) || &#x27;more content&#x27;, &#x27;post_time&#x27;, abs(random() % 1680750000))) from generate_series(1, 1) where username in (select username from users order by random() limit 1);

update timelines set timeline_json = json_insert(timeline_json, &#x27;$[#]&#x27;, json_object(&#x27;tweet_id&#x27;, abs(random() % 2000000), &#x27;poster_id&#x27;, abs(random() % 2000), &#x27;content&#x27;, cast(abs(random()) as text) || &#x27;more content&#x27;, &#x27;post_time&#x27;, abs(random() % 1680750000))) from generate_series(1, 1) where username in (select username from users order by random() limit 1);

update timelines set timeline_json = json_insert(timeline_json, &#x27;$[#]&#x27;, json_object(&#x27;tweet_id&#x27;, abs(random() % 2000000), &#x27;poster_id&#x27;, abs(random() % 2000), &#x27;content&#x27;, cast(abs(random()) as text) || &#x27;more content&#x27;, &#x27;post_time&#x27;, abs(random() % 1680750000))) from generate_series(1, 1) where username in (select username from users order by random() limit 1);

update timelines set timeline_json = json_insert(timeline_json, &#x27;$[#]&#x27;, json_object(&#x27;tweet_id&#x27;, abs(random() % 2000000), &#x27;poster_id&#x27;, abs(random() % 2000), &#x27;content&#x27;, cast(abs(random()) as text) || &#x27;more content&#x27;, &#x27;post_time&#x27;, abs(random() % 1680750000))) from generate_series(1, 1) where username in (select username from users order by random() limit 1);

update timelines set timeline_json = json_insert(timeline_json, &#x27;$[#]&#x27;, json_object(&#x27;tweet_id&#x27;, abs(random() % 2000000), &#x27;poster_id&#x27;, abs(random() % 2000), &#x27;content&#x27;, cast(abs(random()) as text) || &#x27;more content&#x27;, &#x27;post_time&#x27;, abs(random() % 1680750000))) from generate_series(1, 1) where username in (select username from users order by random() limit 1);

update timelines set timeline_json = json_insert(timeline_json, &#x27;$[#]&#x27;, json_object(&#x27;tweet_id&#x27;, abs(random() % 2000000), &#x27;poster_id&#x27;, abs(random() % 2000), &#x27;content&#x27;, cast(abs(random()) as text) || &#x27;more content&#x27;, &#x27;post_time&#x27;, abs(random() % 1680750000))) from generate_series(1, 1) where username in (select username from users order by random() limit 1);

update timelines set timeline_json = json_insert(timeline_json, &#x27;$[#]&#x27;, json_object(&#x27;tweet_id&#x27;, abs(random() % 2000000), &#x27;poster_id&#x27;, abs(random() % 2000), &#x27;content&#x27;, cast(abs(random()) as text) || &#x27;more content&#x27;, &#x27;post_time&#x27;, abs(random() % 1680750000))) from generate_series(1, 1) where username in (select username from users order by random() limit 1);

update timelines set timeline_json = json_insert(timeline_json, &#x27;$[#]&#x27;, json_object(&#x27;tweet_id&#x27;, abs(random() % 2000000), &#x27;poster_id&#x27;, abs(random() % 2000), &#x27;content&#x27;, cast(abs(random()) as text) || &#x27;more content&#x27;, &#x27;post_time&#x27;, abs(random() % 1680750000))) from generate_series(1, 1) where username in (select username from users order by random() limit 1);

update timelines set timeline_json = json_insert(timeline_json, &#x27;$[#]&#x27;, json_object(&#x27;tweet_id&#x27;, abs(random() % 2000000), &#x27;poster_id&#x27;, abs(random() % 2000), &#x27;content&#x27;, cast(abs(random()) as text) || &#x27;more content&#x27;, &#x27;post_time&#x27;, abs(random() % 1680750000))) from generate_series(1, 1) where username in (select username from users order by random() limit 1);

update timelines set timeline_json = json_insert(timeline_json, &#x27;$[#]&#x27;, json_object(&#x27;tweet_id&#x27;, abs(random() % 2000000), &#x27;poster_id&#x27;, abs(random() % 2000), &#x27;content&#x27;, cast(abs(random()) as text) || &#x27;more content&#x27;, &#x27;post_time&#x27;, abs(random() % 1680750000))) from generate_series(1, 1) where username in (select username from users order by random() limit 1);

update timelines set timeline_json = json_insert(timeline_json, &#x27;$[#]&#x27;, json_object(&#x27;tweet_id&#x27;, abs(random() % 2000000), &#x27;poster_id&#x27;, abs(random() % 2000), &#x27;content&#x27;, cast(abs(random()) as text) || &#x27;more content&#x27;, &#x27;post_time&#x27;, abs(random() % 1680750000))) from generate_series(1, 1) where username in (select username from users order by random() limit 1);

update timelines set timeline_json = json_insert(timeline_json, &#x27;$[#]&#x27;, json_object(&#x27;tweet_id&#x27;, abs(random() % 2000000), &#x27;poster_id&#x27;, abs(random() % 2000), &#x27;content&#x27;, cast(abs(random()) as text) || &#x27;more content&#x27;, &#x27;post_time&#x27;, abs(random() % 1680750000))) from generate_series(1, 1) where username in (select username from users order by random() limit 1);

update timelines set timeline_json = json_insert(timeline_json, &#x27;$[#]&#x27;, json_object(&#x27;tweet_id&#x27;, abs(random() % 2000000), &#x27;poster_id&#x27;, abs(random() % 2000), &#x27;content&#x27;, cast(abs(random()) as text) || &#x27;more content&#x27;, &#x27;post_time&#x27;, abs(random() % 1680750000))) from generate_series(1, 1) where username in (select username from users order by random() limit 1);

update timelines set timeline_json = json_insert(timeline_json, &#x27;$[#]&#x27;, json_object(&#x27;tweet_id&#x27;, abs(random() % 2000000), &#x27;poster_id&#x27;, abs(random() % 2000), &#x27;content&#x27;, cast(abs(random()) as text) || &#x27;more content&#x27;, &#x27;post_time&#x27;, abs(random() % 1680750000))) from generate_series(1, 1) where username in (select username from users order by random() limit 1);

update timelines set timeline_json = json_insert(timeline_json, &#x27;$[#]&#x27;, json_object(&#x27;tweet_id&#x27;, abs(random() % 2000000), &#x27;poster_id&#x27;, abs(random() % 2000), &#x27;content&#x27;, cast(abs(random()) as text) || &#x27;more content&#x27;, &#x27;post_time&#x27;, abs(random() % 1680750000))) from generate_series(1, 1) where username in (select username from users order by random() limit 1);

update timelines set timeline_json = json_insert(timeline_json, &#x27;$[#]&#x27;, json_object(&#x27;tweet_id&#x27;, abs(random() % 2000000), &#x27;poster_id&#x27;, abs(random() % 2000), &#x27;content&#x27;, cast(abs(random()) as text) || &#x27;more content&#x27;, &#x27;post_time&#x27;, abs(random() % 1680750000))) from generate_series(1, 1) where username in (select username from users order by random() limit 1);

update timelines set timeline_json = json_insert(timeline_json, &#x27;$[#]&#x27;, json_object(&#x27;tweet_id&#x27;, abs(random() % 2000000), &#x27;poster_id&#x27;, abs(random() % 2000), &#x27;content&#x27;, cast(abs(random()) as text) || &#x27;more content&#x27;, &#x27;post_time&#x27;, abs(random() % 1680750000))) from generate_series(1, 1) where username in (select username from users order by random() limit 1);

update timelines set timeline_json = json_insert(timeline_json, &#x27;$[#]&#x27;, json_object(&#x27;tweet_id&#x27;, abs(random() % 2000000), &#x27;poster_id&#x27;, abs(random() % 2000), &#x27;content&#x27;, cast(abs(random()) as text) || &#x27;more content&#x27;, &#x27;post_time&#x27;, abs(random() % 1680750000))) from generate_series(1, 1) where username in (select username from users order by random() limit 1);

update timelines set timeline_json = json_insert(timeline_json, &#x27;$[#]&#x27;, json_object(&#x27;tweet_id&#x27;, abs(random() % 2000000), &#x27;poster_id&#x27;, abs(random() % 2000), &#x27;content&#x27;, cast(abs(random()) as text) || &#x27;more content&#x27;, &#x27;post_time&#x27;, abs(random() % 1680750000))) from generate_series(1, 1) where username in (select username from users order by random() limit 1);

update timelines set timeline_json = json_insert(timeline_json, &#x27;$[#]&#x27;, json_object(&#x27;tweet_id&#x27;, abs(random() % 2000000), &#x27;poster_id&#x27;, abs(random() % 2000), &#x27;content&#x27;, cast(abs(random()) as text) || &#x27;more content&#x27;, &#x27;post_time&#x27;, abs(random() % 1680750000))) from generate_series(1, 1) where username in (select username from users order by random() limit 1);

update timelines set timeline_json = json_insert(timeline_json, &#x27;$[#]&#x27;, json_object(&#x27;tweet_id&#x27;, abs(random() % 2000000), &#x27;poster_id&#x27;, abs(random() % 2000), &#x27;content&#x27;, cast(abs(random()) as text) || &#x27;more content&#x27;, &#x27;post_time&#x27;, abs(random() % 1680750000))) from generate_series(1, 1) where username in (select username from users order by random() limit 1);

update timelines set timeline_json = json_insert(timeline_json, &#x27;$[#]&#x27;, json_object(&#x27;tweet_id&#x27;, abs(random() % 2000000), &#x27;poster_id&#x27;, abs(random() % 2000), &#x27;content&#x27;, cast(abs(random()) as text) || &#x27;more content&#x27;, &#x27;post_time&#x27;, abs(random() % 1680750000))) from generate_series(1, 1) where username in (select username from users order by random() limit 1);

update timelines set timeline_json = json_insert(timeline_json, &#x27;$[#]&#x27;, json_object(&#x27;tweet_id&#x27;, abs(random() % 2000000), &#x27;poster_id&#x27;, abs(random() % 2000), &#x27;content&#x27;, cast(abs(random()) as text) || &#x27;more content&#x27;, &#x27;post_time&#x27;, abs(random() % 1680750000))) from generate_series(1, 1) where username in (select username from users order by random() limit 1);

update timelines set timeline_json = json_insert(timeline_json, &#x27;$[#]&#x27;, json_object(&#x27;tweet_id&#x27;, abs(random() % 2000000), &#x27;poster_id&#x27;, abs(random() % 2000), &#x27;content&#x27;, cast(abs(random()) as text) || &#x27;more content&#x27;, &#x27;post_time&#x27;, abs(random() % 1680750000))) from generate_series(1, 1) where username in (select username from users order by random() limit 1);

update timelines set timeline_json = json_insert(timeline_json, &#x27;$[#]&#x27;, json_object(&#x27;tweet_id&#x27;, abs(random() % 2000000), &#x27;poster_id&#x27;, abs(random() % 2000), &#x27;content&#x27;, cast(abs(random()) as text) || &#x27;more content&#x27;, &#x27;post_time&#x27;, abs(random() % 1680750000))) from generate_series(1, 1) where username in (select username from users order by random() limit 1);

update timelines set timeline_json = json_insert(timeline_json, &#x27;$[#]&#x27;, json_object(&#x27;tweet_id&#x27;, abs(random() % 2000000), &#x27;poster_id&#x27;, abs(random() % 2000), &#x27;content&#x27;, cast(abs(random()) as text) || &#x27;more content&#x27;, &#x27;post_time&#x27;, abs(random() % 1680750000))) from generate_series(1, 1) where username in (select username from users order by random() limit 1);

update timelines set timeline_json = json_insert(timeline_json, &#x27;$[#]&#x27;, json_object(&#x27;tweet_id&#x27;, abs(random() % 2000000), &#x27;poster_id&#x27;, abs(random() % 2000), &#x27;content&#x27;, cast(abs(random()) as text) || &#x27;more content&#x27;, &#x27;post_time&#x27;, abs(random() % 1680750000))) from generate_series(1, 1) where username in (select username from users order by random() limit 1);

update timelines set timeline_json = json_insert(timeline_json, &#x27;$[#]&#x27;, json_object(&#x27;tweet_id&#x27;, abs(random() % 2000000), &#x27;poster_id&#x27;, abs(random() % 2000), &#x27;content&#x27;, cast(abs(random()) as text) || &#x27;more content&#x27;, &#x27;post_time&#x27;, abs(random() % 1680750000))) from generate_series(1, 1) where username in (select username from users order by random() limit 1);

update timelines set timeline_json = json_insert(timeline_json, &#x27;$[#]&#x27;, json_object(&#x27;tweet_id&#x27;, abs(random() % 2000000), &#x27;poster_id&#x27;, abs(random() % 2000), &#x27;content&#x27;, cast(abs(random()) as text) || &#x27;more content&#x27;, &#x27;post_time&#x27;, abs(random() % 1680750000))) from generate_series(1, 1) where username in (select username from users order by random() limit 1);

update timelines set timeline_json = json_insert(timeline_json, &#x27;$[#]&#x27;, json_object(&#x27;tweet_id&#x27;, abs(random() % 2000000), &#x27;poster_id&#x27;, abs(random() % 2000), &#x27;content&#x27;, cast(abs(random()) as text) || &#x27;more content&#x27;, &#x27;post_time&#x27;, abs(random() % 1680750000))) from generate_series(1, 1) where username in (select username from users order by random() limit 1);

update timelines set timeline_json = json_insert(timeline_json, &#x27;$[#]&#x27;, json_object(&#x27;tweet_id&#x27;, abs(random() % 2000000), &#x27;poster_id&#x27;, abs(random() % 2000), &#x27;content&#x27;, cast(abs(random()) as text) || &#x27;more content&#x27;, &#x27;post_time&#x27;, abs(random() % 1680750000))) from generate_series(1, 1) where username in (select username from users order by random() limit 1);

update timelines set timeline_json = json_insert(timeline_json, &#x27;$[#]&#x27;, json_object(&#x27;tweet_id&#x27;, abs(random() % 2000000), &#x27;poster_id&#x27;, abs(random() % 2000), &#x27;content&#x27;, cast(abs(random()) as text) || &#x27;more content&#x27;, &#x27;post_time&#x27;, abs(random() % 1680750000))) from generate_series(1, 1) where username in (select username from users order by random() limit 1);

update timelines set timeline_json = json_insert(timeline_json, &#x27;$[#]&#x27;, json_object(&#x27;tweet_id&#x27;, abs(random() % 2000000), &#x27;poster_id&#x27;, abs(random() % 2000), &#x27;content&#x27;, cast(abs(random()) as text) || &#x27;more content&#x27;, &#x27;post_time&#x27;, abs(random() % 1680750000))) from generate_series(1, 1) where username in (select username from users order by random() limit 1);

update timelines set timeline_json = json_insert(timeline_json, &#x27;$[#]&#x27;, json_object(&#x27;tweet_id&#x27;, abs(random() % 2000000), &#x27;poster_id&#x27;, abs(random() % 2000), &#x27;content&#x27;, cast(abs(random()) as text) || &#x27;more content&#x27;, &#x27;post_time&#x27;, abs(random() % 1680750000))) from generate_series(1, 1) where username in (select username from users order by random() limit 1);

update timelines set timeline_json = json_insert(timeline_json, &#x27;$[#]&#x27;, json_object(&#x27;tweet_id&#x27;, abs(random() % 2000000), &#x27;poster_id&#x27;, abs(random() % 2000), &#x27;content&#x27;, cast(abs(random()) as text) || &#x27;more content&#x27;, &#x27;post_time&#x27;, abs(random() % 1680750000))) from generate_series(1, 1) where username in (select username from users order by random() limit 1);

update timelines set timeline_json = json_insert(timeline_json, &#x27;$[#]&#x27;, json_object(&#x27;tweet_id&#x27;, abs(random() % 2000000), &#x27;poster_id&#x27;, abs(random() % 2000), &#x27;content&#x27;, cast(abs(random()) as text) || &#x27;more content&#x27;, &#x27;post_time&#x27;, abs(random() % 1680750000))) from generate_series(1, 1) where username in (select username from users order by random() limit 1);

update timelines set timeline_json = json_insert(timeline_json, &#x27;$[#]&#x27;, json_object(&#x27;tweet_id&#x27;, abs(random() % 2000000), &#x27;poster_id&#x27;, abs(random() % 2000), &#x27;content&#x27;, cast(abs(random()) as text) || &#x27;more content&#x27;, &#x27;post_time&#x27;, abs(random() % 1680750000))) from generate_series(1, 1) where username in (select username from users order by random() limit 1);

update timelines set timeline_json = json_insert(timeline_json, &#x27;$[#]&#x27;, json_object(&#x27;tweet_id&#x27;, abs(random() % 2000000), &#x27;poster_id&#x27;, abs(random() % 2000), &#x27;content&#x27;, cast(abs(random()) as text) || &#x27;more content&#x27;, &#x27;post_time&#x27;, abs(random() % 1680750000))) from generate_series(1, 1) where username in (select username from users order by random() limit 1);

update timelines set timeline_json = json_insert(timeline_json, &#x27;$[#]&#x27;, json_object(&#x27;tweet_id&#x27;, abs(random() % 2000000), &#x27;poster_id&#x27;, abs(random() % 2000), &#x27;content&#x27;, cast(abs(random()) as text) || &#x27;more content&#x27;, &#x27;post_time&#x27;, abs(random() % 1680750000))) from generate_series(1, 1) where username in (select username from users order by random() limit 1);

update timelines set timeline_json = json_insert(timeline_json, &#x27;$[#]&#x27;, json_object(&#x27;tweet_id&#x27;, abs(random() % 2000000), &#x27;poster_id&#x27;, abs(random() % 2000), &#x27;content&#x27;, cast(abs(random()) as text) || &#x27;more content&#x27;, &#x27;post_time&#x27;, abs(random() % 1680750000))) from generate_series(1, 1) where username in (select username from users order by random() limit 1);

update timelines set timeline_json = json_insert(timeline_json, &#x27;$[#]&#x27;, json_object(&#x27;tweet_id&#x27;, abs(random() % 2000000), &#x27;poster_id&#x27;, abs(random() % 2000), &#x27;content&#x27;, cast(abs(random()) as text) || &#x27;more content&#x27;, &#x27;post_time&#x27;, abs(random() % 1680750000))) from generate_series(1, 1) where username in (select username from users order by random() limit 1);

update timelines set timeline_json = json_insert(timeline_json, &#x27;$[#]&#x27;, json_object(&#x27;tweet_id&#x27;, abs(random() % 2000000), &#x27;poster_id&#x27;, abs(random() % 2000), &#x27;content&#x27;, cast(abs(random()) as text) || &#x27;more content&#x27;, &#x27;post_time&#x27;, abs(random() % 1680750000))) from generate_series(1, 1) where username in (select username from users order by random() limit 1);

update timelines set timeline_json = json_insert(timeline_json, &#x27;$[#]&#x27;, json_object(&#x27;tweet_id&#x27;, abs(random() % 2000000), &#x27;poster_id&#x27;, abs(random() % 2000), &#x27;content&#x27;, cast(abs(random()) as text) || &#x27;more content&#x27;, &#x27;post_time&#x27;, abs(random() % 1680750000))) from generate_series(1, 1) where username in (select username from users order by random() limit 1);

update timelines set timeline_json = json_insert(timeline_json, &#x27;$[#]&#x27;, json_object(&#x27;tweet_id&#x27;, abs(random() % 2000000), &#x27;poster_id&#x27;, abs(random() % 2000), &#x27;content&#x27;, cast(abs(random()) as text) || &#x27;more content&#x27;, &#x27;post_time&#x27;, abs(random() % 1680750000))) from generate_series(1, 1) where username in (select username from users order by random() limit 1);

update timelines set timeline_json = json_insert(timeline_json, &#x27;$[#]&#x27;, json_object(&#x27;tweet_id&#x27;, abs(random() % 2000000), &#x27;poster_id&#x27;, abs(random() % 2000), &#x27;content&#x27;, cast(abs(random()) as text) || &#x27;more content&#x27;, &#x27;post_time&#x27;, abs(random() % 1680750000))) from generate_series(1, 1) where username in (select username from users order by random() limit 1);

update timelines set timeline_json = json_insert(timeline_json, &#x27;$[#]&#x27;, json_object(&#x27;tweet_id&#x27;, abs(random() % 2000000), &#x27;poster_id&#x27;, abs(random() % 2000), &#x27;content&#x27;, cast(abs(random()) as text) || &#x27;more content&#x27;, &#x27;post_time&#x27;, abs(random() % 1680750000))) from generate_series(1, 1) where username in (select username from users order by random() limit 1);

update timelines set timeline_json = json_insert(timeline_json, &#x27;$[#]&#x27;, json_object(&#x27;tweet_id&#x27;, abs(random() % 2000000), &#x27;poster_id&#x27;, abs(random() % 2000), &#x27;content&#x27;, cast(abs(random()) as text) || &#x27;more content&#x27;, &#x27;post_time&#x27;, abs(random() % 1680750000))) from generate_series(1, 1) where username in (select username from users order by random() limit 1);

update timelines set timeline_json = json_insert(timeline_json, &#x27;$[#]&#x27;, json_object(&#x27;tweet_id&#x27;, abs(random() % 2000000), &#x27;poster_id&#x27;, abs(random() % 2000), &#x27;content&#x27;, cast(abs(random()) as text) || &#x27;more content&#x27;, &#x27;post_time&#x27;, abs(random() % 1680750000))) from generate_series(1, 1) where username in (select username from users order by random() limit 1);

update timelines set timeline_json = json_insert(timeline_json, &#x27;$[#]&#x27;, json_object(&#x27;tweet_id&#x27;, abs(random() % 2000000), &#x27;poster_id&#x27;, abs(random() % 2000), &#x27;content&#x27;, cast(abs(random()) as text) || &#x27;more content&#x27;, &#x27;post_time&#x27;, abs(random() % 1680750000))) from generate_series(1, 1) where username in (select username from users order by random() limit 1);

update timelines set timeline_json = json_insert(timeline_json, &#x27;$[#]&#x27;, json_object(&#x27;tweet_id&#x27;, abs(random() % 2000000), &#x27;poster_id&#x27;, abs(random() % 2000), &#x27;content&#x27;, cast(abs(random()) as text) || &#x27;more content&#x27;, &#x27;post_time&#x27;, abs(random() % 1680750000))) from generate_series(1, 1) where username in (select username from users order by random() limit 1);

update timelines set timeline_json = json_insert(timeline_json, &#x27;$[#]&#x27;, json_object(&#x27;tweet_id&#x27;, abs(random() % 2000000), &#x27;poster_id&#x27;, abs(random() % 2000), &#x27;content&#x27;, cast(abs(random()) as text) || &#x27;more content&#x27;, &#x27;post_time&#x27;, abs(random() % 1680750000))) from generate_series(1, 1) where username in (select username from users order by random() limit 1);

update timelines set timeline_json = json_insert(timeline_json, &#x27;$[#]&#x27;, json_object(&#x27;tweet_id&#x27;, abs(random() % 2000000), &#x27;poster_id&#x27;, abs(random() % 2000), &#x27;content&#x27;, cast(abs(random()) as text) || &#x27;more content&#x27;, &#x27;post_time&#x27;, abs(random() % 1680750000))) from generate_series(1, 1) where username in (select username from users order by random() limit 1);

update timelines set timeline_json = json_insert(timeline_json, &#x27;$[#]&#x27;, json_object(&#x27;tweet_id&#x27;, abs(random() % 2000000), &#x27;poster_id&#x27;, abs(random() % 2000), &#x27;content&#x27;, cast(abs(random()) as text) || &#x27;more content&#x27;, &#x27;post_time&#x27;, abs(random() % 1680750000))) from generate_series(1, 1) where username in (select username from users order by random() limit 1);

update timelines set timeline_json = json_insert(timeline_json, &#x27;$[#]&#x27;, json_object(&#x27;tweet_id&#x27;, abs(random() % 2000000), &#x27;poster_id&#x27;, abs(random() % 2000), &#x27;content&#x27;, cast(abs(random()) as text) || &#x27;more content&#x27;, &#x27;post_time&#x27;, abs(random() % 1680750000))) from generate_series(1, 1) where username in (select username from users order by random() limit 1);

update timelines set timeline_json = json_insert(timeline_json, &#x27;$[#]&#x27;, json_object(&#x27;tweet_id&#x27;, abs(random() % 2000000), &#x27;poster_id&#x27;, abs(random() % 2000), &#x27;content&#x27;, cast(abs(random()) as text) || &#x27;more content&#x27;, &#x27;post_time&#x27;, abs(random() % 1680750000))) from generate_series(1, 1) where username in (select username from users order by random() limit 1);

update timelines set timeline_json = json_insert(timeline_json, &#x27;$[#]&#x27;, json_object(&#x27;tweet_id&#x27;, abs(random() % 2000000), &#x27;poster_id&#x27;, abs(random() % 2000), &#x27;content&#x27;, cast(abs(random()) as text) || &#x27;more content&#x27;, &#x27;post_time&#x27;, abs(random() % 1680750000))) from generate_series(1, 1) where username in (select username from users order by random() limit 1);

update timelines set timeline_json = json_insert(timeline_json, &#x27;$[#]&#x27;, json_object(&#x27;tweet_id&#x27;, abs(random() % 2000000), &#x27;poster_id&#x27;, abs(random() % 2000), &#x27;content&#x27;, cast(abs(random()) as text) || &#x27;more content&#x27;, &#x27;post_time&#x27;, abs(random() % 1680750000))) from generate_series(1, 1) where username in (select username from users order by random() limit 1);

update timelines set timeline_json = json_insert(timeline_json, &#x27;$[#]&#x27;, json_object(&#x27;tweet_id&#x27;, abs(random() % 2000000), &#x27;poster_id&#x27;, abs(random() % 2000), &#x27;content&#x27;, cast(abs(random()) as text) || &#x27;more content&#x27;, &#x27;post_time&#x27;, abs(random() % 1680750000))) from generate_series(1, 1) where username in (select username from users order by random() limit 1);

update timelines set timeline_json = json_insert(timeline_json, &#x27;$[#]&#x27;, json_object(&#x27;tweet_id&#x27;, abs(random() % 2000000), &#x27;poster_id&#x27;, abs(random() % 2000), &#x27;content&#x27;, cast(abs(random()) as text) || &#x27;more content&#x27;, &#x27;post_time&#x27;, abs(random() % 1680750000))) from generate_series(1, 1) where username in (select username from users order by random() limit 1);

update timelines set timeline_json = json_insert(timeline_json, &#x27;$[#]&#x27;, json_object(&#x27;tweet_id&#x27;, abs(random() % 2000000), &#x27;poster_id&#x27;, abs(random() % 2000), &#x27;content&#x27;, cast(abs(random()) as text) || &#x27;more content&#x27;, &#x27;post_time&#x27;, abs(random() % 1680750000))) from generate_series(1, 1) where username in (select username from users order by random() limit 1);

update timelines set timeline_json = json_insert(timeline_json, &#x27;$[#]&#x27;, json_object(&#x27;tweet_id&#x27;, abs(random() % 2000000), &#x27;poster_id&#x27;, abs(random() % 2000), &#x27;content&#x27;, cast(abs(random()) as text) || &#x27;more content&#x27;, &#x27;post_time&#x27;, abs(random() % 1680750000))) from generate_series(1, 1) where username in (select username from users order by random() limit 1);

update timelines set timeline_json = json_insert(timeline_json, &#x27;$[#]&#x27;, json_object(&#x27;tweet_id&#x27;, abs(random() % 2000000), &#x27;poster_id&#x27;, abs(random() % 2000), &#x27;content&#x27;, cast(abs(random()) as text) || &#x27;more content&#x27;, &#x27;post_time&#x27;, abs(random() % 1680750000))) from generate_series(1, 1) where username in (select username from users order by random() limit 1);

update timelines set timeline_json = json_insert(timeline_json, &#x27;$[#]&#x27;, json_object(&#x27;tweet_id&#x27;, abs(random() % 2000000), &#x27;poster_id&#x27;, abs(random() % 2000), &#x27;content&#x27;, cast(abs(random()) as text) || &#x27;more content&#x27;, &#x27;post_time&#x27;, abs(random() % 1680750000))) from generate_series(1, 1) where username in (select username from users order by random() limit 1);

update timelines set timeline_json = json_insert(timeline_json, &#x27;$[#]&#x27;, json_object(&#x27;tweet_id&#x27;, abs(random() % 2000000), &#x27;poster_id&#x27;, abs(random() % 2000), &#x27;content&#x27;, cast(abs(random()) as text) || &#x27;more content&#x27;, &#x27;post_time&#x27;, abs(random() % 1680750000))) from generate_series(1, 1) where username in (select username from users order by random() limit 1);

update timelines set timeline_json = json_insert(timeline_json, &#x27;$[#]&#x27;, json_object(&#x27;tweet_id&#x27;, abs(random() % 2000000), &#x27;poster_id&#x27;, abs(random() % 2000), &#x27;content&#x27;, cast(abs(random()) as text) || &#x27;more content&#x27;, &#x27;post_time&#x27;, abs(random() % 1680750000))) from generate_series(1, 1) where username in (select username from users order by random() limit 1);

update timelines set timeline_json = json_insert(timeline_json, &#x27;$[#]&#x27;, json_object(&#x27;tweet_id&#x27;, abs(random() % 2000000), &#x27;poster_id&#x27;, abs(random() % 2000), &#x27;content&#x27;, cast(abs(random()) as text) || &#x27;more content&#x27;, &#x27;post_time&#x27;, abs(random() % 1680750000))) from generate_series(1, 1) where username in (select username from users order by random() limit 1);

update timelines set timeline_json = json_insert(timeline_json, &#x27;$[#]&#x27;, json_object(&#x27;tweet_id&#x27;, abs(random() % 2000000), &#x27;poster_id&#x27;, abs(random() % 2000), &#x27;content&#x27;, cast(abs(random()) as text) || &#x27;more content&#x27;, &#x27;post_time&#x27;, abs(random() % 1680750000))) from generate_series(1, 1) where username in (select username from users order by random() limit 1);

update timelines set timeline_json = json_insert(timeline_json, &#x27;$[#]&#x27;, json_object(&#x27;tweet_id&#x27;, abs(random() % 2000000), &#x27;poster_id&#x27;, abs(random() % 2000), &#x27;content&#x27;, cast(abs(random()) as text) || &#x27;more content&#x27;, &#x27;post_time&#x27;, abs(random() % 1680750000))) from generate_series(1, 1) where username in (select username from users order by random() limit 1);

update timelines set timeline_json = json_insert(timeline_json, &#x27;$[#]&#x27;, json_object(&#x27;tweet_id&#x27;, abs(random() % 2000000), &#x27;poster_id&#x27;, abs(random() % 2000), &#x27;content&#x27;, cast(abs(random()) as text) || &#x27;more content&#x27;, &#x27;post_time&#x27;, abs(random() % 1680750000))) from generate_series(1, 1) where username in (select username from users order by random() limit 1);

update timelines set timeline_json = json_insert(timeline_json, &#x27;$[#]&#x27;, json_object(&#x27;tweet_id&#x27;, abs(random() % 2000000), &#x27;poster_id&#x27;, abs(random() % 2000), &#x27;content&#x27;, cast(abs(random()) as text) || &#x27;more content&#x27;, &#x27;post_time&#x27;, abs(random() % 1680750000))) from generate_series(1, 1) where username in (select username from users order by random() limit 1);

select &#x27;*** END TIME&#x27;, round(((julianday(&#x27;now&#x27;) - 2440587.5)*86400000.0 - start_time.t) / 1000.0, 3) time_ms from start_time;

commit;
EOF</code></pre></details></li></ul><p id="5d2e47a8-f6cb-4bf4-84d9-cb437de42d70" class="">Start up sqlite3 within the docker container (or in your shell if you’re not using docker).</p><pre id="b84e1008-ca52-4272-82b6-592a486ef761" class="code"><code>sqlite3 # try with file</code></pre><p id="39c7ed1c-555d-4a44-979a-45fe7ee7bbb5" class="">Let’s create the tables we’ll need (same as before):</p><div><pre id="e6b19b10-96a5-47bb-9618-65505b959fb6" class="code code-wrap"><code>create table users (
  id integer primary key,
  username text unique
);

create table tweets (
  id integer primary key,
  poster_id integer references users(id),
  content text,
  post_time integer
);

create table follows (
  follower_id integer references users(id),
  followee_id integer references users(id)
);</code></pre></div><div><pre id="a6a52b95-3317-4eb8-83c6-82f5da1e1ea3" class="code code-wrap"><code>create table timelines (username text unique references users(username), timeline_json text);</code></pre></div><p id="84be3f58-e9df-4a5f-a76a-056ebfedb0de" class="">We’re going to insert some dummy data, TODO of each, this should only take a second or two to complete.</p><pre id="60af3031-1574-47c4-bdbc-a2ac665bcacb" class="code"><code>insert into users (username) select abs(random()) || &#x27;user&#x27; from generate_series(1, 1000);

insert into follows select abs(random() % 1000), abs(random() % 1000) from generate_series(1, 100), users;

# 1680750000, Thu Apr 06 2023 03:00:00 GMT+0000. Was chosen randomly
insert into tweets (poster_id, content, post_time) select abs(random() % 1000), cast(abs(random()) as text) || &#x27; some content&#x27;, abs(random() % 1680750000) from generate_series(1, 500), users;</code></pre><pre id="59acba0c-4369-4cb7-a013-93336c13b01c" class="code code-wrap"><code># note, this will take some time (about TODO seconds on my box), if the
# process dies due to memory or whatever, try rerunning the benchmarking
# section with smaller numbers of users, follows, and tweets (or adjust
# your docker settings).
insert into timelines
select users.username, json_group_array(json_object(&#x27;tweet_id&#x27;, tweets.id, &#x27;poster_id&#x27;, tweets.poster_id, &#x27;content&#x27;, tweets.content, &#x27;post_time&#x27;, tweets.post_time)) from tweets join follows on follows.followee_id = tweets.poster_id join users on users.id = follows.follower_id group by users.username;</code></pre><p id="30713fcc-9ecc-4f0a-89ab-d574627a1c62" class="">Let’s turn on the query timer which will tell us how long each query takes. We’ll use the timer for the first two queries and will hack our own “transaction timer” for the last two queries.</p><pre id="beee78d4-e911-4209-93d3-f1af995c27ea" class="code"><code>.timer on</code></pre><p id="b579d643-7ed7-4771-9f83-f93c456243c5" class=""><strong>Stop</strong> and <strong>think hard</strong> (maybe even do some reading about SQLite TODO links) about these benchmarking questions before you look at the solutions!</p><p id="fe8aa8ff-0c1c-48db-a496-dfa257093fdc" class="">Look over the queries in <code>load_timeline_on_read.sql</code>  and <code>load_timeline_on_write.sql</code> given the amount of dummy data. How much faster do you think load timeline on write will be compared to load timeline on read? Explain your thought process. Take your time and be as thorough as you can. When you’re ready, open the solution up and read.</p><p id="e84b6c7d-28de-484b-9439-324d98ad6e92" class=""><textarea style="width: 100%; font-family: monospace;" rows="5" placeholder="Enter text here (scratch space)"></textarea></p><ul id="6d6ebf4e-1802-491b-bd88-8c5264ec8e68" class="toggle"><li><details><summary style="cursor: pointer">Solution</summary><pre id="d605f4d6-e265-421e-aa1f-3ae2a61f742d" class="code"><code> .read load_timeline_on_read.sql</code></pre><p id="9ea7a1af-504e-4284-82a4-3c13c9bc279e" class="">
</p><pre id="1ff99a35-3c99-46b1-82de-18878f96d647" class="code"><code>.read load_timeline_on_write.sql</code></pre><p id="2c298092-84af-4511-abd4-fe846778a012" class="">TODO investigate sqlite query plan and include details about access, indexes, etc</p></details></li></ul><p id="d619f11e-013c-4e4b-af63-806a8a0eb4b4" class="">Now we’re going to compare how long inserts take using the two approaches. Same gig as above but reversed, how much faster do you think <code>insert_timeline_on_read.sql</code> will be compared to <code>insert_timeline_on_write.sql</code>? Explain your thought process.</p><p id="e49d17cf-17ce-466b-8631-301f52121adc" class=""><textarea style="width: 100%; font-family: monospace;" rows="5" placeholder="Enter text here (scratch space)"></textarea></p><ul id="e68f9e01-061f-4584-89f7-7f47a65d1396" class="toggle"><li><details><summary style="cursor: pointer">Solution</summary><pre id="1c7d77b4-61e2-4872-91a8-9345fb0855ed" class="code"><code>.read insert_timeline_on_read.sql</code></pre><p id="cc57ad7a-48f9-4e88-b6df-07c2ec80bbb0" class="">
</p><pre id="d35418c6-979d-4da8-ad2e-9aa02d6b334e" class="code"><code>.read insert_timeline_on_write.sql</code></pre><p id="9a803814-9a9a-4b53-9be3-0c47e181e4b0" class="">TODO</p></details></li></ul><p id="0ba46ac3-0393-4682-a430-e53c9c3e9a87" class="">TODO</p><p id="1fc30aa0-b8df-4725-9a9c-6e369f601822" class="">So inserting a tweet into 100 timelines is slower than just inserting a single tweet into the tweets table, but it’s still reasonably fast using sqlite. However, think about how slow this could get if a user had millions of followers, which would mean you have to copy that tweet into millions of timelines.</p><p id="c6f693cd-47c0-4bc6-9e8c-2f0522b56e60" class="">Caveat: I didn’t go into alternative ways to implement this, but instead focused on these 2 options with the hope that they are somewhat representative of common data systems which developers are designing and building but more so to give us a concrete example about which to discuss things like scalability and maintainability. I didn’t explore things like indexing, caching, denormalization, alternative data models, etc. TODO single writer, mem vs disk, etc.</p><h1 id="2dd92ded-49e0-4d3a-b8d8-dbcb30c27d44" class="">Conclusion</h1><p id="3eb90b56-5b23-4f2f-ae38-ecb33588ccd1" class="">Alright, you made it! Well done. This article is a taste of what to expect in this Designing Data-Intensive Applications supplemental course. Here’s a summary of some main points:</p><p id="13190b91-03dd-43b8-820d-687223ea8710" class="">It depends is “always” the right answer when thinking about system design. It depends on the assumptions you make about how the system will be used and the tradeoffs you want.</p><p id="0e3a044e-0533-4632-8c9c-5a8da17dcd9b" class="">Wrote some SQL to support a super simplified Twitter in SQLite.</p><p id="400a190a-a660-4073-a746-3556b18e9691" class="">When evaluating a system design, some high level ideas to consider are its performance, scalability, reliability, and maintainability. Here we primarily discussed how our timeline implementation affects performance, though we touched a bit on scalability and maintainability as well.</p><p id="4427b160-c6f2-420c-b2c4-8dfa5b8b60a4" class="">TODO did some benchmarking to prototype timeline-on-read vs timeline-on-write and learning about how SQLite does stuff?</p><p id="7d980783-04a9-4b56-ae4b-ffa213cc1542" class="">
</p><p id="ea89a3cd-5be2-4fcf-9383-47bdad30f9cf" class="">I do want to add that most future labs will go deeper into the technical details (e.g.: topics like replication and more details on data system internals), see this <a href="../Designing-Data-Intensive-Applications-Course.html">list of future topics</a>, but this lab was meant to give a general intro to thinking about system design tradeoffs.</p><p id="783795cd-ac2e-46c4-8313-0273ff773577" class="">Fin. Head back to <a href="../Designing-Data-Intensive-Applications-Course.html">Chapter 1</a> to continue the course.</p><p id="7069fe1e-bb7b-49a2-a0a4-b93bc994d203" class="">
</p><figure id="535dcbef-80bf-41b9-8d23-673af5219ab4" class="image"><a href="Lab-1-1-Twitter-Timeline/frodo-its-done.gif"><img style="width:480px" src="Lab-1-1-Twitter-Timeline/frodo-its-done.gif"/></a></figure><h2 id="9685d1ac-f074-4a14-9a2b-fa2e58b85199" class="">Misc</h2><pre id="a7114a4a-900e-4532-8d9e-ef9a07d65e39" class="code code-wrap"><code>select json_array_length(timeline_json) from timelines where username = &#x27;alice&#x27;;</code></pre><p id="19dbfdce-f204-4091-88e7-f29dffb469d9" class="">TODO add li and bullet points to font sizing format script</p><p id="fddb7392-7263-4b51-8403-abb936347113" class="">TODO finalize, get feedback, once i’m relatively happy with it then add other mediums and get feedback on those</p></div></article></body></html>