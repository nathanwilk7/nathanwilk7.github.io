<html><head>
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-LEEFT9748K"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-LEEFT9748K');
</script>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=DM+Sans&display=swap" rel="stylesheet">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Lab 0.1 - Twitter Timeline</title><style>

body, h1, h2, h3, a, p {
	font-family: 'DM Sans', sans-serif;
	letter-spacing: .02em;
	font-size: 1.2rem;
}

/* cspell:disable-file */
/* webkit printing magic: print all background colors */
html {
	-webkit-print-color-adjust: exact;
}
* {
	box-sizing: border-box;
	-webkit-print-color-adjust: exact;
}

html,
body {
	margin: 0;
	padding: 0;
}
@media only screen {
	body {
		margin: 2em auto;
		max-width: 900px;
		color: rgb(55, 53, 47);
	}
}

body {
	line-height: 1.5;
	white-space: pre-wrap;
}

a,
a.visited {
	color: inherit;
	text-decoration: underline;
}

.pdf-relative-link-path {
	font-size: 80%;
	color: #444;
}

h1,
h2,
h3 {
	letter-spacing: -0.01em;
	line-height: 1.2;
	font-weight: 600;
	margin-bottom: 0;
}

.page-title {
	font-size: 2.5rem;
	font-weight: 700;
	margin-top: 0;
	margin-bottom: 0.75em;
}

h1 {
	font-size: 1.875rem;
	margin-top: 1.875rem;
}

h2 {
	font-size: 1.5rem;
	margin-top: 1.5rem;
}

h3 {
	font-size: 1.25rem;
	margin-top: 1.25rem;
}

.source {
	border: 1px solid #ddd;
	border-radius: 3px;
	padding: 1.5em;
	word-break: break-all;
}

.callout {
	border-radius: 3px;
	padding: 1rem;
}

figure {
	margin: 1.25em 0;
	page-break-inside: avoid;
}

figcaption {
	opacity: 0.5;
	font-size: 85%;
	margin-top: 0.5em;
}

mark {
	background-color: transparent;
}

.indented {
	padding-left: 1.5em;
}

hr {
	background: transparent;
	display: block;
	width: 100%;
	height: 1px;
	visibility: visible;
	border: none;
	border-bottom: 1px solid rgba(55, 53, 47, 0.09);
}

img {
	max-width: 100%;
}

@media only print {
	img {
		max-height: 100vh;
		object-fit: contain;
	}
}

@page {
	margin: 1in;
}

.collection-content {
	font-size: 0.875rem;
}

.column-list {
	display: flex;
	justify-content: space-between;
}

.column {
	padding: 0 1em;
}

.column:first-child {
	padding-left: 0;
}

.column:last-child {
	padding-right: 0;
}

.table_of_contents-item {
	display: block;
	font-size: 0.875rem;
	line-height: 1.3;
	padding: 0.125rem;
}

.table_of_contents-indent-1 {
	margin-left: 1.5rem;
}

.table_of_contents-indent-2 {
	margin-left: 3rem;
}

.table_of_contents-indent-3 {
	margin-left: 4.5rem;
}

.table_of_contents-link {
	text-decoration: none;
	opacity: 0.7;
	border-bottom: 1px solid rgba(55, 53, 47, 0.18);
}

table,
th,
td {
	border: 1px solid rgba(55, 53, 47, 0.09);
	border-collapse: collapse;
}

table {
	border-left: none;
	border-right: none;
}

th,
td {
	font-weight: normal;
	padding: 0.25em 0.5em;
	line-height: 1.5;
	min-height: 1.5em;
	text-align: left;
}

th {
	color: rgba(55, 53, 47, 0.6);
}

ol,
ul {
	margin: 0;
	margin-block-start: 0.6em;
	margin-block-end: 0.6em;
}

li > ol:first-child,
li > ul:first-child {
	margin-block-start: 0.6em;
}

ul > li {
	list-style: disc;
}

ul.to-do-list {
	padding-inline-start: 0;
}

ul.to-do-list > li {
	list-style: none;
}

.to-do-children-checked {
	text-decoration: line-through;
	opacity: 0.375;
}

ul.toggle > li {
	list-style: none;
}

ul {
	padding-inline-start: 1.7em;
}

ul > li {
	padding-left: 0.1em;
}

ol {
	padding-inline-start: 1.6em;
}

ol > li {
	padding-left: 0.2em;
}

.mono ol {
	padding-inline-start: 2em;
}

.mono ol > li {
	text-indent: -0.4em;
}

.toggle {
	padding-inline-start: 0em;
	list-style-type: none;
}

/* Indent toggle children */
.toggle > li > details {
	padding-left: 1.7em;
}

.toggle > li > details > summary {
	margin-left: -1.1em;
}

.selected-value {
	display: inline-block;
	padding: 0 0.5em;
	background: rgba(206, 205, 202, 0.5);
	border-radius: 3px;
	margin-right: 0.5em;
	margin-top: 0.3em;
	margin-bottom: 0.3em;
	white-space: nowrap;
}

.collection-title {
	display: inline-block;
	margin-right: 1em;
}

.simple-table {
	margin-top: 1em;
	font-size: 0.875rem;
	empty-cells: show;
}
.simple-table td {
	height: 29px;
	min-width: 120px;
}

.simple-table th {
	height: 29px;
	min-width: 120px;
}

.simple-table-header-color {
	background: rgb(247, 246, 243);
	color: black;
}
.simple-table-header {
	font-weight: 500;
}

time {
	opacity: 0.5;
}

.icon {
	display: inline-block;
	max-width: 1.2em;
	max-height: 1.2em;
	text-decoration: none;
	vertical-align: text-bottom;
	margin-right: 0.5em;
}

img.icon {
	border-radius: 3px;
}

.user-icon {
	width: 1.5em;
	height: 1.5em;
	border-radius: 100%;
	margin-right: 0.5rem;
}

.user-icon-inner {
	font-size: 0.8em;
}

.text-icon {
	border: 1px solid #000;
	text-align: center;
}

.page-cover-image {
	display: block;
	object-fit: cover;
	width: 100%;
	max-height: 30vh;
}

.page-header-icon {
	font-size: 3rem;
	margin-bottom: 1rem;
}

.page-header-icon-with-cover {
	margin-top: -0.72em;
	margin-left: 0.07em;
}

.page-header-icon img {
	border-radius: 3px;
}

.link-to-page {
	margin: 1em 0;
	padding: 0;
	border: none;
	font-weight: 500;
}

p > .user {
	opacity: 0.5;
}

td > .user,
td > time {
	white-space: nowrap;
}

input[type="checkbox"] {
	transform: scale(1.5);
	margin-right: 0.6em;
	vertical-align: middle;
}

p {
	margin-top: 0.5em;
	margin-bottom: 0.5em;
}

.image {
	border: none;
	margin: 1.5em 0;
	padding: 0;
	border-radius: 0;
	text-align: center;
}

.code,
code {
	background: rgba(135, 131, 120, 0.15);
	border-radius: 3px;
	padding: 0.2em 0.4em;
	border-radius: 3px;
	font-size: 85%;
	tab-size: 2;
}

code {
	color: #eb5757;
}

.code {
	padding: 1.5em 1em;
}

.code-wrap {
	white-space: pre-wrap;
	word-break: break-all;
}

.code > code {
	background: none;
	padding: 0;
	font-size: 100%;
	color: inherit;
}

blockquote {
	font-size: 1.25em;
	margin: 1em 0;
	padding-left: 1em;
	border-left: 3px solid rgb(55, 53, 47);
}

.bookmark {
	text-decoration: none;
	max-height: 8em;
	padding: 0;
	display: flex;
	width: 100%;
	align-items: stretch;
}

.bookmark-title {
	font-size: 0.85em;
	overflow: hidden;
	text-overflow: ellipsis;
	height: 1.75em;
	white-space: nowrap;
}

.bookmark-text {
	display: flex;
	flex-direction: column;
}

.bookmark-info {
	flex: 4 1 180px;
	padding: 12px 14px 14px;
	display: flex;
	flex-direction: column;
	justify-content: space-between;
}

.bookmark-image {
	width: 33%;
	flex: 1 1 180px;
	display: block;
	position: relative;
	object-fit: cover;
	border-radius: 1px;
}

.bookmark-description {
	color: rgba(55, 53, 47, 0.6);
	font-size: 0.75em;
	overflow: hidden;
	max-height: 4.5em;
	word-break: break-word;
}

.bookmark-href {
	font-size: 0.75em;
	margin-top: 0.25em;
}

.sans { font-family: ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol"; }
.code { font-family: "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace; }
.serif { font-family: Lyon-Text, Georgia, ui-serif, serif; }
.mono { font-family: iawriter-mono, Nitti, Menlo, Courier, monospace; }
.pdf .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK JP'; }
.pdf:lang(zh-CN) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK SC'; }
.pdf:lang(zh-TW) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK TC'; }
.pdf:lang(ko-KR) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK KR'; }
.pdf .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK JP'; }
.pdf:lang(zh-CN) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK SC'; }
.pdf:lang(zh-TW) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK TC'; }
.pdf:lang(ko-KR) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK KR'; }
.pdf .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK JP'; }
.pdf:lang(zh-CN) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK SC'; }
.pdf:lang(zh-TW) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK TC'; }
.pdf:lang(ko-KR) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK KR'; }
.pdf .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK JP'; }
.pdf:lang(zh-CN) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK SC'; }
.pdf:lang(zh-TW) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK TC'; }
.pdf:lang(ko-KR) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK KR'; }
.highlight-default {
	color: rgba(55, 53, 47, 1);
}
.highlight-gray {
	color: rgba(120, 119, 116, 1);
	fill: rgba(120, 119, 116, 1);
}
.highlight-brown {
	color: rgba(159, 107, 83, 1);
	fill: rgba(159, 107, 83, 1);
}
.highlight-orange {
	color: rgba(217, 115, 13, 1);
	fill: rgba(217, 115, 13, 1);
}
.highlight-yellow {
	color: rgba(203, 145, 47, 1);
	fill: rgba(203, 145, 47, 1);
}
.highlight-teal {
	color: rgba(68, 131, 97, 1);
	fill: rgba(68, 131, 97, 1);
}
.highlight-blue {
	color: rgba(51, 126, 169, 1);
	fill: rgba(51, 126, 169, 1);
}
.highlight-purple {
	color: rgba(144, 101, 176, 1);
	fill: rgba(144, 101, 176, 1);
}
.highlight-pink {
	color: rgba(193, 76, 138, 1);
	fill: rgba(193, 76, 138, 1);
}
.highlight-red {
	color: rgba(212, 76, 71, 1);
	fill: rgba(212, 76, 71, 1);
}
.highlight-gray_background {
	background: rgba(241, 241, 239, 1);
}
.highlight-brown_background {
	background: rgba(244, 238, 238, 1);
}
.highlight-orange_background {
	background: rgba(251, 236, 221, 1);
}
.highlight-yellow_background {
	background: rgba(251, 243, 219, 1);
}
.highlight-teal_background {
	background: rgba(237, 243, 236, 1);
}
.highlight-blue_background {
	background: rgba(231, 243, 248, 1);
}
.highlight-purple_background {
	background: rgba(244, 240, 247, 0.8);
}
.highlight-pink_background {
	background: rgba(249, 238, 243, 0.8);
}
.highlight-red_background {
	background: rgba(253, 235, 236, 1);
}
.block-color-default {
	color: inherit;
	fill: inherit;
}
.block-color-gray {
	color: rgba(120, 119, 116, 1);
	fill: rgba(120, 119, 116, 1);
}
.block-color-brown {
	color: rgba(159, 107, 83, 1);
	fill: rgba(159, 107, 83, 1);
}
.block-color-orange {
	color: rgba(217, 115, 13, 1);
	fill: rgba(217, 115, 13, 1);
}
.block-color-yellow {
	color: rgba(203, 145, 47, 1);
	fill: rgba(203, 145, 47, 1);
}
.block-color-teal {
	color: rgba(68, 131, 97, 1);
	fill: rgba(68, 131, 97, 1);
}
.block-color-blue {
	color: rgba(51, 126, 169, 1);
	fill: rgba(51, 126, 169, 1);
}
.block-color-purple {
	color: rgba(144, 101, 176, 1);
	fill: rgba(144, 101, 176, 1);
}
.block-color-pink {
	color: rgba(193, 76, 138, 1);
	fill: rgba(193, 76, 138, 1);
}
.block-color-red {
	color: rgba(212, 76, 71, 1);
	fill: rgba(212, 76, 71, 1);
}
.block-color-gray_background {
	background: rgba(241, 241, 239, 1);
}
.block-color-brown_background {
	background: rgba(244, 238, 238, 1);
}
.block-color-orange_background {
	background: rgba(251, 236, 221, 1);
}
.block-color-yellow_background {
	background: rgba(251, 243, 219, 1);
}
.block-color-teal_background {
	background: rgba(237, 243, 236, 1);
}
.block-color-blue_background {
	background: rgba(231, 243, 248, 1);
}
.block-color-purple_background {
	background: rgba(244, 240, 247, 0.8);
}
.block-color-pink_background {
	background: rgba(249, 238, 243, 0.8);
}
.block-color-red_background {
	background: rgba(253, 235, 236, 1);
}
.select-value-color-pink { background-color: rgba(245, 224, 233, 1); }
.select-value-color-purple { background-color: rgba(232, 222, 238, 1); }
.select-value-color-green { background-color: rgba(219, 237, 219, 1); }
.select-value-color-gray { background-color: rgba(227, 226, 224, 1); }
.select-value-color-opaquegray { background-color: rgba(255, 255, 255, 0.0375); }
.select-value-color-orange { background-color: rgba(250, 222, 201, 1); }
.select-value-color-brown { background-color: rgba(238, 224, 218, 1); }
.select-value-color-red { background-color: rgba(255, 226, 221, 1); }
.select-value-color-yellow { background-color: rgba(253, 236, 200, 1); }
.select-value-color-blue { background-color: rgba(211, 229, 239, 1); }

.checkbox {
	display: inline-flex;
	vertical-align: text-bottom;
	width: 16;
	height: 16;
	background-size: 16px;
	margin-left: 2px;
	margin-right: 5px;
}

.checkbox-on {
	background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg-width%3D%2216%22-height%3D%2216%22-viewBox%3D%220-0-16-16%22-fill%3D%22none%22-xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%3Crect-width%3D%2216%22-height%3D%2216%22-fill%3D%22%2358A9D7%22%2F%3E%0A%3Cpath-d%3D%22M6.71429-12.2852L14-4.9995L12.7143-3.71436L6.71429-9.71378L3.28571-6.2831L2-7.57092L6.71429-12.2852Z%22-fill%3D%22white%22%2F%3E%0A%3C%2Fsvg%3E");
}

.checkbox-off {
	background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg-width%3D%2216%22-height%3D%2216%22-viewBox%3D%220-0-16-16%22-fill%3D%22none%22-xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%3Crect-x%3D%220.75%22-y%3D%220.75%22-width%3D%2214.5%22-height%3D%2214.5%22-fill%3D%22white%22-stroke%3D%22%2336352F%22-stroke-width%3D%221.5%22%2F%3E%0A%3C%2Fsvg%3E");
}
	

@media (max-width: 575.98px) {
	body {
		padding-left: 1rem;
		padding-right: 1rem;
		font-size: 2.2rem;
	}
	a {
		font-size: 2.2rem;
	}
	h1 {
		font-size: Fsrem;
	}
	h2 {
		font-size: 2.2rem;
	}
	h3 {
		font-size: 2.2rem;
	}
	img {
   		max-width: 90%;
  	  	min-width: 36px;
 	   	height: auto;
	}
}


@media (max-width: 767.98px) {
	body {
		padding-left: 1rem;
		padding-right: 1rem;
		font-size: 2.0rem;
	}
	a {
		font-size: 2.0rem;
	}
	h1 {
		font-size: Fsrem;
	}
	h2 {
		font-size: 2.0rem;
	}
	h3 {
		font-size: 2.0rem;
	}
	img {
   		max-width: 90%;
  	  	min-width: 36px;
 	   	height: auto;
	}
}


@media (max-width: 991.98px) {
	body {
		padding-left: 1rem;
		padding-right: 1rem;
		font-size: 1.8rem;
	}
	a {
		font-size: 1.8rem;
	}
	h1 {
		font-size: Fsrem;
	}
	h2 {
		font-size: 1.8rem;
	}
	h3 {
		font-size: 1.8rem;
	}
	img {
   		max-width: 90%;
  	  	min-width: 36px;
 	   	height: auto;
	}
}


@media (max-width: 1199.98px) {
	body {
		padding-left: 1rem;
		padding-right: 1rem;
		font-size: 1.6rem;
	}
	a {
		font-size: 1.6rem;
	}
	h1 {
		font-size: Fsrem;
	}
	h2 {
		font-size: 1.6rem;
	}
	h3 {
		font-size: 1.6rem;
	}
	img {
   		max-width: 90%;
  	  	min-width: 36px;
 	   	height: auto;
	}
}


@media (max-width: 1399.98px) {
	body {
		padding-left: 1rem;
		padding-right: 1rem;
		font-size: 1.4rem;
	}
	a {
		font-size: 1.4rem;
	}
	h1 {
		font-size: Fsrem;
	}
	h2 {
		font-size: 1.4rem;
	}
	h3 {
		font-size: 1.4rem;
	}
	img {
   		max-width: 90%;
  	  	min-width: 36px;
 	   	height: auto;
	}
}
</style></head><body><article id="408f6a11-b784-4b31-a1ae-14f76ae20204" class="page sans"><header><h1 class="page-title">Lab 0.1 - Twitter Timeline</h1></header><div class="page-body"><div><p id="d623529e-b42e-4f3e-9faf-93b865c175cc" class="">Data Al Dente</p><p id="7f8dacda-5257-4c3b-86df-a683e1b85c55" class=""><a href="../../../index.html">Home</a> | <a href="../../Posts.html">Posts</a> | <a href="../../About-Me.html">About Me</a></p></div><p id="b15e1f4a-9b01-4024-826c-07a9d85de895" class="">Created <time>@April 5, 2023</time> </p><p id="1d28af4f-61be-4a31-baa2-de2885d14871" class="">Updated <time>@April 5, 2023</time> </p><ul id="518b45fb-e6e8-42df-a1e3-2d54883134d5" class="toggle"><li><details open=""><summary>Outline</summary><nav id="82a10be0-8879-494b-84fd-798b6592bcaa" class="block-color-gray table_of_contents"><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#fe038e15-9430-49be-8710-81f5cb70cbc9">Prerequisites</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#d171a26e-39b3-463d-9929-36148ccb9760">Setup</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#47ab4027-1e5d-46d2-a88a-159234ae525c">Verify Setup</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#aca35f58-d673-46db-bb6f-4995863972cb">Context/Gameplan</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#12963d3a-1528-4141-ad5c-1b135e7e17e6">Entities/Nouns/Data Model</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#9afb1ca5-682f-4192-94a3-067a4c420f14">Option 1: Timeline on Read</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#4100ab49-6442-43ae-9b3e-9863b86e64e9">Option 2: Timeline on Write</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#3c49bcd4-6eed-41dc-922d-0c3213befa5c">Comparing Timeline on Read vs Write</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#2f5ee4b3-c79b-437d-bc7e-d96a55c0f9f2">Benchmarking</a></div></nav></details></li></ul><h1 id="fe038e15-9430-49be-8710-81f5cb70cbc9" class="">Prerequisites</h1><p id="3b94a843-d02e-473b-b4be-51214cc7c025" class="">You should read the Preface and Chapter 1 (Reliable, Scalable, and Maintainable Applications) of Designing Data-Intensive Applications before completing this lab.</p><h1 id="d171a26e-39b3-463d-9929-36148ccb9760" class="">Setup</h1><p id="a8838522-5338-4174-9677-0a3078c2bb1a" class="">Install Docker: <a href="https://docs.docker.com/engine/install/">https://docs.docker.com/engine/install/</a></p><p id="8f510858-ddb6-48ef-8cca-c166e8f2de32" class="">Ensure docker is running (you may need to open the Docker application)</p><p id="ad96cdcf-cb49-4629-b92c-36e1166e4632" class="">Note, if you’ve already got sqlite installed and don’t want to use docker, then you could just run the command <code>sqlite3</code> instead for this lab.</p><h1 id="47ab4027-1e5d-46d2-a88a-159234ae525c" class="">Verify Setup</h1><p id="90eac99c-3b27-4bad-9ea1-a4bea6908a7d" class="">Each command should output the commented out lines directly below it:</p><pre id="fc018211-8aa2-4b0b-a998-5d30ec66a377" class="code code-wrap"><code>docker run --rm -it keinos/sqlite3
# SQLite version 3.A.B 2023-CC-DD EE:FF:GG
# Enter &quot;.help&quot; for usage hints.
# Connected to a transient in-memory database.
# Use &quot;.open FILENAME&quot; to reopen on a persistent database.
# sqlite&gt;

select 1 + 1;
# 2

# You can exit the sqlite prompt by typing CTRL-C or CTRL-D. If you exit, any tables or data you&#x27;ve defined will be lost.</code></pre><h1 id="aca35f58-d673-46db-bb6f-4995863972cb" class="">Context/Gameplan</h1><p id="72f11f5a-2262-47c6-b552-476c55c8ae3e" class="">We’re going to implement a super simple version of the twitter timeline using SQLite. We’re going to try out two different ways of implementing the timeline and evaluate their tradeoffs.</p><p id="c8a2c4fb-b4c0-4c86-bca3-3baa00f97369" class="">Roughly, a Twitter timeline works like this.</p><ol type="1" id="d05e9734-1f59-4748-a6d1-317bd53c422c" class="numbered-list" start="1"><li>A user U1 posts a tweet (a tweet for our purposes is just a string).</li></ol><ol type="1" id="2a41661d-8235-4cdc-88a1-a5fd10d8ede7" class="numbered-list" start="2"><li>A user U2 posts a tweet.</li></ol><ol type="1" id="4e07440e-14f1-4219-aedc-f863af70e03f" class="numbered-list" start="3"><li>A different user U3 loads their timeline.</li></ol><ol type="1" id="9aebf864-ce21-4f22-a026-6401b75d2a2d" class="numbered-list" start="4"><li>When user U3 loads their timeline, the tweets from all the users U3 follows are displayed sorted by time.</li></ol><p id="9dcdc6af-9ba8-4915-9c67-801f63a078e2" class="">Note, we’re going to have the timeline sorted in time ascending order instead of descending order to keep things simpler, but of course in real life you’d do descending. Also, we’re not going to worry about keeping track of which tweets a user has already read, to keep things simple we’ll just show all the tweets in the timeline every time we load it.</p><h1 id="12963d3a-1528-4141-ad5c-1b135e7e17e6" class="">Entities/Nouns/Data Model</h1><p id="4585bd64-b133-454b-9245-22b1df372a4e" class="">The key entities/nouns here are:</p><ul id="9d9461a5-0105-4611-9121-87da6d46ea65" class="bulleted-list"><li style="list-style-type:disc">Users</li></ul><ul id="4220e829-8692-4926-8680-d978356278f5" class="bulleted-list"><li style="list-style-type:disc">Tweets</li></ul><ul id="48a5d208-74f4-423c-9933-87cdb16834b2" class="bulleted-list"><li style="list-style-type:disc">Follows</li></ul><figure id="f9aa997f-3eeb-4770-911d-1bf6483b8429" class="image"><a href="Lab-0-1---Twitter-Timeline/Untitled.png"><img style="width:934px" src="Lab-0-1---Twitter-Timeline/Untitled.png"/></a></figure><p id="6f861ea4-15ea-4cce-b57e-4cbfcb6801b1" class=""><a href="https://whimsical.com/lab-0-1-entities-data-model-GVgogWwQiMcsU5roiByNjK">https://whimsical.com/lab-0-1-entities-data-model-GVgogWwQiMcsU5roiByNjK</a></p><p id="7aac5884-0ccc-4de2-89ac-f3ca45ee1856" class="">If you disconnected from your SQLite database, rerun this to reconnect. Don’t disconnect for the rest of this lab (or you’ll have to restart from here).</p><pre id="fbf8e91b-a40b-49be-a1b8-021caa843f79" class="code code-wrap"><code>docker run --rm -it keinos/sqlite3</code></pre><p id="ebb29ca7-13d8-4be0-bf9c-87b4fe65df31" class="">Let’s create tables for users, tweets, and follows in our SQLite database.</p><pre id="e6b19b10-96a5-47bb-9618-65505b959fb6" class="code code-wrap"><code>create table users (
  id integer primary key,
  username text unique
);

create table tweets (
  id integer primary key,
  poster_id integer references users(id),
  content text,
  post_time integer default (unixepoch())
);

create table follows (
  follower_id integer references users(id),
  followee_id integer references users(id)
);</code></pre><p id="eac57d6c-540b-4e17-9ac8-c120de42d269" class="">Note that we’re not using autoincrement/serial for our primary key in SQLite even though it’s standard in many other databases like Postgres. I want to avoid making you understand SQLite’s ROWID, but if you’re using SQLite for real, you should read to understand primary keys, ROWID and autoincrement in SQLite: <a href="https://www.sqlite.org/autoinc.html">https://www.sqlite.org/autoinc.html</a> and <a href="https://www.sqlite.org/lang_createtable.html#rowid">https://www.sqlite.org/lang_createtable.html#rowid</a>.</p><p id="7620b3a4-3f37-4f0e-b91c-d2428d9965ba" class="">Verify that the tables were created:</p><pre id="ea6a07bd-b9b4-4a52-a675-2bee9deeb31c" class="code code-wrap"><code>.tables
# follows  tweets   users</code></pre><p id="34a9a435-2b83-475a-b066-c625421c972c" class="">Let’s also turn on headers to make queries easier to understand:</p><pre id="4b2b9729-5a2d-453c-bca8-bd07c259eca8" class="code code-wrap"><code># shows the table column names when we select
.headers on

# tell sqlite to enforce foreign keys? if i don&#x27;t have this then inserting it easy...
TODO makes it harder later
# PRAGMA foreign_keys = ON;</code></pre><p id="c2577885-84f4-4863-bceb-03080370a50b" class="">Ok, we’re ready to start implementing the timeline feature.</p><h1 id="9afb1ca5-682f-4192-94a3-067a4c420f14" class="">Option 1: Timeline on Read</h1><p id="439d5512-5739-48b1-a033-eb3b0aa4f3ff" class="">One way you could implement timelines is by writing a query which requests all the tweets from the users a given user follows sorted by time. We’re going to write that query. First, let’s add some simple dummy data for users and follows.</p><pre id="7a0085f5-3fcc-4d1b-9881-f097ccb13deb" class="code code-wrap"><code>insert into users (username) values (&#x27;alice&#x27;), (&#x27;bob&#x27;), (&#x27;charlie&#x27;), (&#x27;david&#x27;);

insert into follows select alice.id, bob.id from users alice, users bob where alice.username = &#x27;alice&#x27; and bob.username = &#x27;bob&#x27;;
insert into follows select alice.id, charlie.id from users alice, users charlie where alice.username = &#x27;alice&#x27; and charlie.username = &#x27;charlie&#x27;;</code></pre><p id="b7e490ba-5ce9-4f1e-a670-3f39338c494a" class="">So what we’re done here is create 4 users with the usernames <code>alice</code>, <code>bob</code>, <code>charlie</code>, and <code>david</code> and then <code>alice</code> has started following <code>bob</code> and <code>charlie</code> (but not <code>david</code>).</p><p id="dc6d7be5-bf68-45c9-84ac-6c02724e35ef" class="">Let’s verify that our users and follows were inserted correctly (it’s ok if the id’s chosen by SQLite differ or the order of rows returned differs):</p><pre id="b3961a3e-78bc-4665-abba-f6d4a3681697" class="code code-wrap"><code>select * from users;
# id|username
# 1|alice
# 2|bob
# 3|charlie
# 4|david

select * from follows;
# follower_id|followee_id
# 1|2
# 1|3</code></pre><p id="02609c4c-41b3-4a73-b3ae-ee3bf53b3792" class="">Now we’re going to create some tweets.</p><pre id="df1380bb-5465-4162-8681-d02b2ed106dd" class="code code-wrap"><code>insert into tweets (poster_id, content, post_time) select alice.id, &#x27;alice first tweet&#x27;, 0 from users alice where alice.username = &#x27;alice&#x27;;

insert into tweets (poster_id, content, post_time) select bob.id, &#x27;bob first tweet&#x27;, 1 from users bob where bob.username = &#x27;bob&#x27;;

insert into tweets (poster_id, content, post_time) select charlie.id, &#x27;charlie first tweet&#x27;, 2 from users charlie where charlie.username = &#x27;charlie&#x27;;

insert into tweets (poster_id, content, post_time) select bob.id, &#x27;bob second tweet&#x27;, 3 from users bob where bob.username = &#x27;bob&#x27;;

insert into tweets (poster_id, content, post_time) select david.id, &#x27;david first tweet&#x27;, 4 from users david where david.username = &#x27;david&#x27;;</code></pre><p id="f4d8e1ef-ad29-4b81-82f3-645c72790859" class="">Note that we hardcoded the <code>post_time</code> for these tweets to be between 1 and 4. This is just to keep things simple for now, later we’ll insert tweets using the current time as the default.</p><p id="5161eb7a-f23e-41d6-a7ff-db767dcb65ec" class="">TODO get rid of default time?</p><p id="e25cccee-403b-4609-a7ff-17971e531eeb" class="">Let’s verify the tweets we inserted (we’re going to order the results by <code>post_time</code>):</p><pre id="6531f488-edb5-45d1-bda9-f34a3a028aca" class="code code-wrap"><code>select * from tweets order by post_time;
# id|poster_id|content|post_time
# 1|1|alice first tweet|0
# 2|2|bob first tweet|1
# 3|3|charlie first tweet|2
# 4|2|bob second tweet|3
# 5|4|david first tweet|4</code></pre><p id="84815360-8251-4c07-93f4-87c2252762fe" class="">Great, so we can see there are 5 tweets, 1 from <code>alice</code>, 2 from <code>bob</code>, 1 from <code>charlie</code>, and 1 from <code>david</code>. The order of tweets by <code>post_time</code> is:</p><ul id="c8d4c022-44e9-45f7-964d-15c0eb29f210" class="bulleted-list"><li style="list-style-type:disc"><code>alice</code>&#x27;s first tweet.</li></ul><ul id="0691fa0c-a280-4f48-b1c9-b0b8af3de2b1" class="bulleted-list"><li style="list-style-type:disc"><code>bob</code>&#x27;s first tweet.</li></ul><ul id="789e77bc-cebd-46a0-957c-d0fbdf6885e3" class="bulleted-list"><li style="list-style-type:disc"><code>charlie</code>&#x27;s first tweet.</li></ul><ul id="2771bb79-8ce4-44ca-afc6-123f783dd932" class="bulleted-list"><li style="list-style-type:disc"><code>bob</code>&#x27;s second tweet.</li></ul><ul id="fa6f6db5-1248-4780-9a84-7898628db5a6" class="bulleted-list"><li style="list-style-type:disc"><code>david</code>&#x27;s first tweet.</li></ul><p id="f18bf120-b91c-4ced-b313-bc4829ffb69f" class="">Ok, now it’s your turn to try to figure out how to write a query which does the following: Given a user ID, load all the tweets (id, poster_id, content, and post_time) for that users timeline sorted by the <code>post_time</code>. Remember that a user’s timeline should have all the tweets from that user’s “followees”.</p><p id="82d27e5f-2250-4004-85f9-9c22359a6a74" class="">TODO replace TEXTAREA with an html one?</p><p id="1691e1c7-19b9-4399-ad0e-8fbe9394eec1" class="">TEXTAREA</p><ul id="2b84b472-166f-4058-a08e-bb34070f9ca9" class="toggle"><li><details open=""><summary>Hint 1: Here’s an example query which shows how to get the user IDs for a users’s “followees”</summary><pre id="41a5f89b-e621-4251-948a-fadc37d93e95" class="code code-wrap"><code>select f.followee_id from users given_user join follows f on f.follower_id = given_user.id where given_user.username = &#x27;alice&#x27;;
# followee_id
# 2
# 3

# or if you prefer to use id instead of username
select f.followee_id from follows f where f.follower_id = 1;
# followee_id
# 2
# 3</code></pre></details></li></ul><ul id="6947b825-271b-46f2-8069-026dfb13d2d7" class="toggle"><li><details open=""><summary>Solution</summary><pre id="e37f50a1-4c20-4118-bdf7-5a5285fbb691" class="code code-wrap"><code>select t.* from users given_user join follows f on f.follower_id = given_user.id join tweets t on t.poster_id = f.followee_id where given_user.username = &#x27;alice&#x27; order by t.post_time;
TODO


# or if your prefer to use id instead of username
select t.* from follows f join tweets t on t.poster_id = f.followee_id where f.follower_id = 1 order by t.post_time;
TODO
</code></pre></details></li></ul><p id="8f400921-da53-481a-beab-82c7dcf46a33" class="">So, once you figured out or looked at the solution, I have a question for you. Do you think this design for implementing timelines is a good solution? Is it performant? Is it scalable? Is it reliable?</p><ul id="de7c32ff-b53c-4219-a117-dba36dae64ed" class="toggle"><li><details open=""><summary>Answer</summary><p id="eabd6aee-185d-4266-8baf-2356c9ea1799" class="">The correct answer to this question is, “it depends.” And it turns out that “it depends” is almost always the correct answer when evaluating any design. In other words, asking if a system design is “good” without more details is not a reasonable question to ask given the information you have. We’ll talk more about this below and throughout this course, but it’s crucial to remember that every design makes tradeoffs and those tradeoffs are based on assumptions about how the system will be used. Is it write-heavy or read-heavy? Is downtime acceptable or unacceptable? Who are the users and administrators? What types of reads and writes should be supported? How long of response time is acceptable? etc, etc, etc. I’ll have some examples of more well founded questions below this but I want to point out that it’s not useful to design a system in a vacuum, you should design based on the tradeoffs and assumptions you want in the system.</p><p id="adfb0fdc-a245-4970-b807-1876a3943e75" class="">If you’re like me, when you first thought about this question, you thought some things like, “well it’s using SQLite so that means it will only run on a single instance, so it can be scaled vertically but not horizontally and SQLite only supports a single writer at a time” and “the query as written will be slow as the number of tweets and follows grows because it has to look up all the necessary tweets and sort them each time you run it”. These are (I think), reasonable things to think, but I’m trying to make the point that all designs must be built around the problem they’re trying to solve and there is no one size fits all magic solution which is always the right call. For example, if you’re writing an embedded system which needs to store relational data on a small USB flash drive, then SQLite is probably a good choice. However, if you need highly scalable relational data storage with high writes per second for a worldwide internet-based system, then SQLite is likely not the right choice of database.</p></details></li></ul><p id="110756dc-d75d-4dbc-bfcb-98237c038863" class="">To get a better handle on these kinds of questions, we’re going to discuss another approach to how you could handle timelines and then follow up by comparing and contrasting their reliability, scalability, and maintainability in a more concrete way.</p><h1 id="4100ab49-6442-43ae-9b3e-9863b86e64e9" class="">Option 2: Timeline on Write</h1><p id="8da18ace-761f-4dee-83e1-e36bc763b6af" class="">We’re going to try a different way to implement timelines, in this method, we’ll keep a timeline for each user and every time a tweet is posted, then we’ll append that tweet to all the the timelines of all the followers of the user who posted the tweet.</p><p id="15d3d1b3-ba63-4d6e-b78f-d12efc21e675" class="">First, let’s create a timelines table.</p><p id="f1d6916a-b10c-4439-b653-5cab2504d9d3" class="">Side note, we’re going to do something a little weird here, which is to use a JSON array in SQLite for each user’s timeline. This probably isn’t the best way to do this, but I think it will be sufficient for this demonstration. Also, I’m using username instead of user ID here because it simplifies the queries below.</p><pre id="a6a52b95-3317-4eb8-83c6-82f5da1e1ea3" class="code code-wrap"><code>create table timelines (username text unique references users(username), timeline_json text);</code></pre><p id="d504f5e8-23d7-4d37-a27c-1b4d63f548d8" class="">Let’s insert the tweets from our tweets table into this timelines table to show how it works. Note that the code below is pretty hacky and you’d probably do something better than this in real life. We’re essentially using the timelines table as a key value store where the key is the user ID and the value is a JSON array of the user’s timeline.</p><pre id="4ca74d4b-db03-4fdb-8691-d33a2c8dfa46" class="code code-wrap"><code># create an empty array for each user&#x27;s id.
insert into timelines select username, json_array() from users;

# now each user has an empty JSON array for their timeline
select * from timelines;
TODO

TODO avoid long text in code blocks since it formats poorly or fix it

# alice is the only user who has followed anyone at this point, so let&#x27;s
# insert the tweets from her followees into alice&#x27;s timeline. Note that the
# order matters here since we&#x27;re appending to an array
update timelines set timeline_json = json_insert(timeline_json, &#x27;$[#]&#x27;, json_object(&#x27;tweet_id&#x27;, tweets.id, &#x27;poster_id&#x27;, tweets.poster_id, &#x27;content&#x27;, tweets.content, &#x27;post_time&#x27;, tweets.post_time)) from (select tweets.*, users.username poster_username from tweets where content = &#x27;bob first tweet&#x27;) tweets where username = &#x27;alice&#x27;;

update timelines set timeline_json = json_insert(timeline_json, &#x27;$[#]&#x27;, json_object(&#x27;tweet_id&#x27;, tweets.id, &#x27;poster_id&#x27;, tweets.poster_id, &#x27;content&#x27;, tweets.content, &#x27;post_time&#x27;, tweets.post_time)) from (select tweets.*, users.username poster_username from tweets where content = &#x27;charlie first tweet&#x27;) tweets where username = &#x27;alice&#x27;;

update timelines set timeline_json = json_insert(timeline_json, &#x27;$[#]&#x27;, json_object(&#x27;tweet_id&#x27;, tweets.id, &#x27;poster_id&#x27;, tweets.poster_id, &#x27;content&#x27;, tweets.content, &#x27;post_time&#x27;, tweets.post_time)) from (select tweets.*, users.username poster_username from tweets where content = &#x27;bob second tweet&#x27;) tweets where username = &#x27;alice&#x27;;

# now if we look at the timelines, we&#x27;ll see that alice&#x27;s is populated with
# the expected tweets
select * from timelines;</code></pre><p id="e13469a3-f4d6-4115-a2f8-20be0dccfd0f" class="">So now we can load up Alice’s timeline using the timelines table like this:</p><pre id="371fbeed-e340-4972-b638-06a1c84e177e" class="code code-wrap"><code># load as JSON
select timeline_json from timelines where username = &#x27;alice&#x27;;

# load as rows
select je.value from timelines, json_each(timelines.timeline_json) je where username = &#x27;alice&#x27;;</code></pre><p id="69314f01-ef59-409b-8d7e-5c5625c1c83b" class="">Note that in the example loading as rows I’m assuming <code>json_each</code> returns the rows in order, just doing this to make it simpler.</p><h1 id="3c49bcd4-6eed-41dc-922d-0c3213befa5c" class="">Comparing Timeline on Read vs Write</h1><p id="f7e792ea-c9cc-47bd-9891-297e09bb2e45" class="">Now we have two options for how to implement timelines, we can either compute them on read using option 1 or we can compute them on write using option 2.</p><p id="7a999581-13b1-497a-aa1a-359c5795f775" class="">I want to make sure we’re clear on exactly how option 1 and 2 work, so let’s walk through them in more detail.</p><p id="faf0944b-359d-413c-95a4-cc437d98dabd" class="">In option 1, whenever a user posts a tweet, that tweet is inserted into the tweets table. Whenever a user loads their timeline, then the query to load the timeline searches over the entire tweets table, finds the tweets of the user’s followees, and sorts them by time. Therefore with this option posting tweets is not very much work for the database, but loading the timeline is lots of work for the database.</p><p id="38c699eb-dbd2-4484-8609-3ca842e4b86a" class="">In option 2, whenever a user posts a tweet, that tweet is still inserted into the tweets table, but it is also inserted into every followee’s timeline. Then, instead of loading the timeline for a user from the tweets table, it can simply be loaded from the timelines table. Therefore with this option posting tweets can be a lot of work for the database (depending on how many followers a poster has), but loading the timeline is not not much work for the database.</p><p id="4987ebec-e8f8-4f63-9660-2ab1c4f21e19" class="">Let’s talk about which option is “better”.</p><p id="3643d9c5-ab3e-4cd0-b26d-72736c20c572" class="">Hopefully you remember our recent discussion about “it depends” and so when I said let’s talk about which one is better, you thought to yourself, “it depends”. But what does it depend on? Let’s examine a few tradeoffs between the two approaches:</p><ul id="ec498e2a-76bb-4fa1-ae49-fb1bd55d4c7f" class="bulleted-list"><li style="list-style-type:disc">Are there going to be more reads or writes? This question is crucial to designing this system because the two options will have very different performance for reads vs writes. In option 1, we expect writes to be fast, but reads to be slow. In option 2, we expect the opposite, writes should be slow while reads should be fast. So, if our system is going to have significantly more tweet posts than timeline reads, then we should probably compute the timeline on read. Alternatively, if our system is going to have significantly more timeline reads than tweet posts, then we should probably compute the timeline on write.</li></ul><ul id="dda2098b-b151-41ca-8449-11d1c7a43bad" class="bulleted-list"><li style="list-style-type:disc">How many followers and followees do users have? The more followers and followees a user has, the more “fan-out” occurs (e.g.: timelines require more work for users with more followers). This question affects both option 1 and 2. In option 1, more followers means that we’ll have to return more tweets in the timeline (and therefore load more of the tweets table, even if it’s well indexed). In option 2, more followers means that we’ll have to write to more timelines.</li></ul><ul id="c4ac50f5-e4c1-4006-bea3-2f6d10e691e7" class="bulleted-list"><li style="list-style-type:disc">How much storage space is available? Option 1 will use much less storage space than option 2 because option 1 only stores tweets once. In option 2, tweets are copied for every follower when a tweet is posted. If we use option 2, we should make sure we are ok with how much disk space it’s going to use.</li></ul><ul id="32576abd-d4be-42e6-be4a-a7815b5e980f" class="bulleted-list"><li style="list-style-type:disc">Which option is more maintainable? There are two aspects of maintainability I want to address here (specifically going to focus on simplicity and evolvability here). I think option 1 is simpler than option 2. Option 2 is complex for a few reasons:<ul id="cd51b562-251f-40a7-bc87-be8fa5764f7f" class="bulleted-list"><li style="list-style-type:circle">Requires keeping multiple inserts across multiple tables in sync each time a tweet is posted. This means developers have to be careful when making changes to the code which inserts tweets. I do like that in option 2 it gives a simple abstraction for developers reading timelines, they just select the relevant row from the timelines table. This is simpler than the more complex timeline query in option 1, however I think maintaining a slightly complex SQL query is much easier than maintaining the more complex logic keeping multiple table in sync.</li></ul><ul id="48a53fbf-d926-4f28-9295-00fd5f51f9ca" class="bulleted-list"><li style="list-style-type:circle">Duplicated tweets would be difficult to update or delete since you’d have to update them in all relevant timelines in addition to the tweets table.</li></ul><ul id="64063a0c-330e-439e-9112-6d7de696a67f" class="bulleted-list"><li style="list-style-type:circle">Uses a schema-on-read (schemaless) approach. Because tweets are stored simply as JSON, there is no guarantee from the database about what fields exist in the JSON or what types those fields have. This means that whenever the fields on a tweet are updated then the code which reads the JSON timeline cannot assume that those fields exist on all tweets, therefore it must parse and verify the schema while reading the JSON. This is opposed to schema-on-write where all fields are guaranteed to exist and have a type (e.g.: a normal SQLite table). Given that we’re also storing tweets as a separate table, I think keeping that separate table and the timelines objects in sync is a pain.</li></ul></li></ul><p id="864e2ccf-c098-47e5-bebd-5d58441a414c" class="">Given this discussion above, I would plan to use option 1 if writes outnumber reads or if they occur at roughly the same frequency. However, if there are significantly more reads than writes, I would use option 2. Let’s try to do some quick benchmarking to see if we can get a more concrete idea of read vs write performance.</p><h1 id="2f5ee4b3-c79b-437d-bc7e-d96a55c0f9f2" class="">Benchmarking</h1><p id="e8974f9e-e1be-48a9-b084-d84e3e86e6a5" class="">Let’s insert a bunch more dummy data and see if we can get enough data loaded to see a difference between how long reads and writes take.</p><p id="891b01e8-386d-4469-938c-aaa42a35bdc9" class="">We’ll do 2000 users, have each user follow 100 users, and have each user post 1000 tweets.</p><pre id="92895735-fe7e-4dde-9fe9-0cc5f7d014d0" class="code code-wrap"><code>insert into users (username) select abs(random()) || &#x27;user&#x27; from generate_series(1, 2000);

insert into follows select abs(random() % 10000), abs(random() % 10000) from generate_series(1, 100), users;

insert into tweets (poster_id, content, post_time) select abs(random() % 10000), cast(abs(random()) as text) || &#x27; some content&#x27;, abs(random() % 1680750000) from generate_series(1, 1000), users;</code></pre><p id="4ca55eb2-c449-4940-90bf-c15e6c1e300e" class="">TODO</p><pre id="cd4c06fe-6473-4415-93f3-c424953f7465" class="code code-wrap"><code># shows how long the query took to run
.timer on</code></pre><pre id="bc0609b4-172e-433f-96e5-2137c42f790c" class="code code-wrap"><code>select t.* from users given_user join follows f on f.follower_id = given_user.id join tweets t on t.poster_id = f.followee_id where given_user.username = &#x27;alice&#x27; order by t.post_time limit 10;</code></pre><p id="e222a30e-118d-4b62-aa4f-b754543aa841" class="">TODO obviously i’m not using indexes etc but the point here remains that trading off read work vs write work makes a big difference. also talk a bit about denormalization (eg space vs time tradeoff) and how it affects updating.</p><p id="b5b2fc76-4723-4278-9929-ce435d9b8969" class="">TODO recreate or delte timelines table?</p><pre id="2a2f1a4e-6141-4e46-852f-f0607ab135b7" class="code code-wrap"><code># note, this will take some time, doing a lot of work
insert into timelines
select users.username, json_group_array(json_object(&#x27;tweet_id&#x27;, tweets.id, &#x27;poster_id&#x27;, tweets.poster_id, &#x27;content&#x27;, tweets.content, &#x27;post_time&#x27;, tweets.post_time)) from tweets join follows on follows.followee_id = tweets.poster_id join users on users.id = follows.follower_id group by users.username;</code></pre><p id="e275b011-3969-469d-8886-85c593c2ddf5" class="">Getting timeline with option 2 is super quick.</p><pre id="7ab066c5-40fc-4410-a4b7-2048e9a1c853" class="code code-wrap"><code>select username, timeline_json -&gt; 0, timeline_json -&gt; 1, timeline_json -&gt; 2, timeline_json -&gt; 3, timeline_json -&gt; 4, timeline_json -&gt; 5, timeline_json -&gt; 6, timeline_json -&gt; 7, timeline_json -&gt; 8, timeline_json -&gt; 9 from timelines where username = &#x27;alice&#x27;</code></pre><p id="4ae50419-07ce-436e-a486-792f4a3da5b7" class="">TODO include timings in the above and talk about them</p><p id="4e9bc22e-a64b-4133-976b-e2cb75803059" class="">Note that since we didn’t keep it in order while generating the timelines table, then timeline_json is in random order, but in real life you’d keep it in order by inserting as will be shown below.</p><p id="8a7cf4a5-45d7-45ae-9aa3-8ebad12d5774" class="">
</p><p id="13b7492e-d7c7-4261-b7e9-46a0ff870380" class="">TODO replace option 1 and 2 with their real name</p><p id="9231eeb3-656d-4bdc-b0d6-5a0f818d1093" class="">TODO then compare individual insert performance (use begin for whole tweet things).</p><pre id="f014ef7b-1dd1-454d-b9a3-6d8a450f00d7" class="code code-wrap"><code># option 1
insert into tweets (poster_id, content, post_time) values (1, cast(abs(random()) as text) || &#x27; moar content&#x27;, abs(random() % 1680750000));</code></pre><p id="ae38c7e2-3fd2-46e4-8938-84c63f63dbd5" class="">TODO vs option 2 (in a toggle, which you may need to expand)</p><ul id="85343662-099f-49d2-b88d-843a1c125fe7" class="toggle"><li><details open=""><summary>YOOHOO I put this query in a toggle because it’s huge and makes scrolling a pain, expand it to see it.</summary><pre id="e4148daf-507f-4d27-8e64-60eb680dfaef" class="code code-wrap"><code># option 2
begin transaction;

update timelines set timeline_json = json_insert(timeline_json, &#x27;$[#]&#x27;, json_object(&#x27;tweet_id&#x27;, abs(random() % 2000000), &#x27;poster_id&#x27;, abs(random() % 2000), &#x27;content&#x27;, cast(abs(random()) as text) || &#x27;more content&#x27;, &#x27;post_time&#x27;, abs(random() % 1680750000))) from generate_series(1, 1) where username in (select username from users order by random() limit 1);

update timelines set timeline_json = json_insert(timeline_json, &#x27;$[#]&#x27;, json_object(&#x27;tweet_id&#x27;, abs(random() % 2000000), &#x27;poster_id&#x27;, abs(random() % 2000), &#x27;content&#x27;, cast(abs(random()) as text) || &#x27;more content&#x27;, &#x27;post_time&#x27;, abs(random() % 1680750000))) from generate_series(1, 1) where username in (select username from users order by random() limit 1);

update timelines set timeline_json = json_insert(timeline_json, &#x27;$[#]&#x27;, json_object(&#x27;tweet_id&#x27;, abs(random() % 2000000), &#x27;poster_id&#x27;, abs(random() % 2000), &#x27;content&#x27;, cast(abs(random()) as text) || &#x27;more content&#x27;, &#x27;post_time&#x27;, abs(random() % 1680750000))) from generate_series(1, 1) where username in (select username from users order by random() limit 1);

update timelines set timeline_json = json_insert(timeline_json, &#x27;$[#]&#x27;, json_object(&#x27;tweet_id&#x27;, abs(random() % 2000000), &#x27;poster_id&#x27;, abs(random() % 2000), &#x27;content&#x27;, cast(abs(random()) as text) || &#x27;more content&#x27;, &#x27;post_time&#x27;, abs(random() % 1680750000))) from generate_series(1, 1) where username in (select username from users order by random() limit 1);

update timelines set timeline_json = json_insert(timeline_json, &#x27;$[#]&#x27;, json_object(&#x27;tweet_id&#x27;, abs(random() % 2000000), &#x27;poster_id&#x27;, abs(random() % 2000), &#x27;content&#x27;, cast(abs(random()) as text) || &#x27;more content&#x27;, &#x27;post_time&#x27;, abs(random() % 1680750000))) from generate_series(1, 1) where username in (select username from users order by random() limit 1);

update timelines set timeline_json = json_insert(timeline_json, &#x27;$[#]&#x27;, json_object(&#x27;tweet_id&#x27;, abs(random() % 2000000), &#x27;poster_id&#x27;, abs(random() % 2000), &#x27;content&#x27;, cast(abs(random()) as text) || &#x27;more content&#x27;, &#x27;post_time&#x27;, abs(random() % 1680750000))) from generate_series(1, 1) where username in (select username from users order by random() limit 1);

update timelines set timeline_json = json_insert(timeline_json, &#x27;$[#]&#x27;, json_object(&#x27;tweet_id&#x27;, abs(random() % 2000000), &#x27;poster_id&#x27;, abs(random() % 2000), &#x27;content&#x27;, cast(abs(random()) as text) || &#x27;more content&#x27;, &#x27;post_time&#x27;, abs(random() % 1680750000))) from generate_series(1, 1) where username in (select username from users order by random() limit 1);

update timelines set timeline_json = json_insert(timeline_json, &#x27;$[#]&#x27;, json_object(&#x27;tweet_id&#x27;, abs(random() % 2000000), &#x27;poster_id&#x27;, abs(random() % 2000), &#x27;content&#x27;, cast(abs(random()) as text) || &#x27;more content&#x27;, &#x27;post_time&#x27;, abs(random() % 1680750000))) from generate_series(1, 1) where username in (select username from users order by random() limit 1);

update timelines set timeline_json = json_insert(timeline_json, &#x27;$[#]&#x27;, json_object(&#x27;tweet_id&#x27;, abs(random() % 2000000), &#x27;poster_id&#x27;, abs(random() % 2000), &#x27;content&#x27;, cast(abs(random()) as text) || &#x27;more content&#x27;, &#x27;post_time&#x27;, abs(random() % 1680750000))) from generate_series(1, 1) where username in (select username from users order by random() limit 1);

update timelines set timeline_json = json_insert(timeline_json, &#x27;$[#]&#x27;, json_object(&#x27;tweet_id&#x27;, abs(random() % 2000000), &#x27;poster_id&#x27;, abs(random() % 2000), &#x27;content&#x27;, cast(abs(random()) as text) || &#x27;more content&#x27;, &#x27;post_time&#x27;, abs(random() % 1680750000))) from generate_series(1, 1) where username in (select username from users order by random() limit 1);

update timelines set timeline_json = json_insert(timeline_json, &#x27;$[#]&#x27;, json_object(&#x27;tweet_id&#x27;, abs(random() % 2000000), &#x27;poster_id&#x27;, abs(random() % 2000), &#x27;content&#x27;, cast(abs(random()) as text) || &#x27;more content&#x27;, &#x27;post_time&#x27;, abs(random() % 1680750000))) from generate_series(1, 1) where username in (select username from users order by random() limit 1);

update timelines set timeline_json = json_insert(timeline_json, &#x27;$[#]&#x27;, json_object(&#x27;tweet_id&#x27;, abs(random() % 2000000), &#x27;poster_id&#x27;, abs(random() % 2000), &#x27;content&#x27;, cast(abs(random()) as text) || &#x27;more content&#x27;, &#x27;post_time&#x27;, abs(random() % 1680750000))) from generate_series(1, 1) where username in (select username from users order by random() limit 1);

update timelines set timeline_json = json_insert(timeline_json, &#x27;$[#]&#x27;, json_object(&#x27;tweet_id&#x27;, abs(random() % 2000000), &#x27;poster_id&#x27;, abs(random() % 2000), &#x27;content&#x27;, cast(abs(random()) as text) || &#x27;more content&#x27;, &#x27;post_time&#x27;, abs(random() % 1680750000))) from generate_series(1, 1) where username in (select username from users order by random() limit 1);

update timelines set timeline_json = json_insert(timeline_json, &#x27;$[#]&#x27;, json_object(&#x27;tweet_id&#x27;, abs(random() % 2000000), &#x27;poster_id&#x27;, abs(random() % 2000), &#x27;content&#x27;, cast(abs(random()) as text) || &#x27;more content&#x27;, &#x27;post_time&#x27;, abs(random() % 1680750000))) from generate_series(1, 1) where username in (select username from users order by random() limit 1);

update timelines set timeline_json = json_insert(timeline_json, &#x27;$[#]&#x27;, json_object(&#x27;tweet_id&#x27;, abs(random() % 2000000), &#x27;poster_id&#x27;, abs(random() % 2000), &#x27;content&#x27;, cast(abs(random()) as text) || &#x27;more content&#x27;, &#x27;post_time&#x27;, abs(random() % 1680750000))) from generate_series(1, 1) where username in (select username from users order by random() limit 1);

update timelines set timeline_json = json_insert(timeline_json, &#x27;$[#]&#x27;, json_object(&#x27;tweet_id&#x27;, abs(random() % 2000000), &#x27;poster_id&#x27;, abs(random() % 2000), &#x27;content&#x27;, cast(abs(random()) as text) || &#x27;more content&#x27;, &#x27;post_time&#x27;, abs(random() % 1680750000))) from generate_series(1, 1) where username in (select username from users order by random() limit 1);

update timelines set timeline_json = json_insert(timeline_json, &#x27;$[#]&#x27;, json_object(&#x27;tweet_id&#x27;, abs(random() % 2000000), &#x27;poster_id&#x27;, abs(random() % 2000), &#x27;content&#x27;, cast(abs(random()) as text) || &#x27;more content&#x27;, &#x27;post_time&#x27;, abs(random() % 1680750000))) from generate_series(1, 1) where username in (select username from users order by random() limit 1);

update timelines set timeline_json = json_insert(timeline_json, &#x27;$[#]&#x27;, json_object(&#x27;tweet_id&#x27;, abs(random() % 2000000), &#x27;poster_id&#x27;, abs(random() % 2000), &#x27;content&#x27;, cast(abs(random()) as text) || &#x27;more content&#x27;, &#x27;post_time&#x27;, abs(random() % 1680750000))) from generate_series(1, 1) where username in (select username from users order by random() limit 1);

update timelines set timeline_json = json_insert(timeline_json, &#x27;$[#]&#x27;, json_object(&#x27;tweet_id&#x27;, abs(random() % 2000000), &#x27;poster_id&#x27;, abs(random() % 2000), &#x27;content&#x27;, cast(abs(random()) as text) || &#x27;more content&#x27;, &#x27;post_time&#x27;, abs(random() % 1680750000))) from generate_series(1, 1) where username in (select username from users order by random() limit 1);

update timelines set timeline_json = json_insert(timeline_json, &#x27;$[#]&#x27;, json_object(&#x27;tweet_id&#x27;, abs(random() % 2000000), &#x27;poster_id&#x27;, abs(random() % 2000), &#x27;content&#x27;, cast(abs(random()) as text) || &#x27;more content&#x27;, &#x27;post_time&#x27;, abs(random() % 1680750000))) from generate_series(1, 1) where username in (select username from users order by random() limit 1);

update timelines set timeline_json = json_insert(timeline_json, &#x27;$[#]&#x27;, json_object(&#x27;tweet_id&#x27;, abs(random() % 2000000), &#x27;poster_id&#x27;, abs(random() % 2000), &#x27;content&#x27;, cast(abs(random()) as text) || &#x27;more content&#x27;, &#x27;post_time&#x27;, abs(random() % 1680750000))) from generate_series(1, 1) where username in (select username from users order by random() limit 1);

update timelines set timeline_json = json_insert(timeline_json, &#x27;$[#]&#x27;, json_object(&#x27;tweet_id&#x27;, abs(random() % 2000000), &#x27;poster_id&#x27;, abs(random() % 2000), &#x27;content&#x27;, cast(abs(random()) as text) || &#x27;more content&#x27;, &#x27;post_time&#x27;, abs(random() % 1680750000))) from generate_series(1, 1) where username in (select username from users order by random() limit 1);

update timelines set timeline_json = json_insert(timeline_json, &#x27;$[#]&#x27;, json_object(&#x27;tweet_id&#x27;, abs(random() % 2000000), &#x27;poster_id&#x27;, abs(random() % 2000), &#x27;content&#x27;, cast(abs(random()) as text) || &#x27;more content&#x27;, &#x27;post_time&#x27;, abs(random() % 1680750000))) from generate_series(1, 1) where username in (select username from users order by random() limit 1);

update timelines set timeline_json = json_insert(timeline_json, &#x27;$[#]&#x27;, json_object(&#x27;tweet_id&#x27;, abs(random() % 2000000), &#x27;poster_id&#x27;, abs(random() % 2000), &#x27;content&#x27;, cast(abs(random()) as text) || &#x27;more content&#x27;, &#x27;post_time&#x27;, abs(random() % 1680750000))) from generate_series(1, 1) where username in (select username from users order by random() limit 1);

update timelines set timeline_json = json_insert(timeline_json, &#x27;$[#]&#x27;, json_object(&#x27;tweet_id&#x27;, abs(random() % 2000000), &#x27;poster_id&#x27;, abs(random() % 2000), &#x27;content&#x27;, cast(abs(random()) as text) || &#x27;more content&#x27;, &#x27;post_time&#x27;, abs(random() % 1680750000))) from generate_series(1, 1) where username in (select username from users order by random() limit 1);

update timelines set timeline_json = json_insert(timeline_json, &#x27;$[#]&#x27;, json_object(&#x27;tweet_id&#x27;, abs(random() % 2000000), &#x27;poster_id&#x27;, abs(random() % 2000), &#x27;content&#x27;, cast(abs(random()) as text) || &#x27;more content&#x27;, &#x27;post_time&#x27;, abs(random() % 1680750000))) from generate_series(1, 1) where username in (select username from users order by random() limit 1);

update timelines set timeline_json = json_insert(timeline_json, &#x27;$[#]&#x27;, json_object(&#x27;tweet_id&#x27;, abs(random() % 2000000), &#x27;poster_id&#x27;, abs(random() % 2000), &#x27;content&#x27;, cast(abs(random()) as text) || &#x27;more content&#x27;, &#x27;post_time&#x27;, abs(random() % 1680750000))) from generate_series(1, 1) where username in (select username from users order by random() limit 1);

update timelines set timeline_json = json_insert(timeline_json, &#x27;$[#]&#x27;, json_object(&#x27;tweet_id&#x27;, abs(random() % 2000000), &#x27;poster_id&#x27;, abs(random() % 2000), &#x27;content&#x27;, cast(abs(random()) as text) || &#x27;more content&#x27;, &#x27;post_time&#x27;, abs(random() % 1680750000))) from generate_series(1, 1) where username in (select username from users order by random() limit 1);

update timelines set timeline_json = json_insert(timeline_json, &#x27;$[#]&#x27;, json_object(&#x27;tweet_id&#x27;, abs(random() % 2000000), &#x27;poster_id&#x27;, abs(random() % 2000), &#x27;content&#x27;, cast(abs(random()) as text) || &#x27;more content&#x27;, &#x27;post_time&#x27;, abs(random() % 1680750000))) from generate_series(1, 1) where username in (select username from users order by random() limit 1);

update timelines set timeline_json = json_insert(timeline_json, &#x27;$[#]&#x27;, json_object(&#x27;tweet_id&#x27;, abs(random() % 2000000), &#x27;poster_id&#x27;, abs(random() % 2000), &#x27;content&#x27;, cast(abs(random()) as text) || &#x27;more content&#x27;, &#x27;post_time&#x27;, abs(random() % 1680750000))) from generate_series(1, 1) where username in (select username from users order by random() limit 1);

update timelines set timeline_json = json_insert(timeline_json, &#x27;$[#]&#x27;, json_object(&#x27;tweet_id&#x27;, abs(random() % 2000000), &#x27;poster_id&#x27;, abs(random() % 2000), &#x27;content&#x27;, cast(abs(random()) as text) || &#x27;more content&#x27;, &#x27;post_time&#x27;, abs(random() % 1680750000))) from generate_series(1, 1) where username in (select username from users order by random() limit 1);

update timelines set timeline_json = json_insert(timeline_json, &#x27;$[#]&#x27;, json_object(&#x27;tweet_id&#x27;, abs(random() % 2000000), &#x27;poster_id&#x27;, abs(random() % 2000), &#x27;content&#x27;, cast(abs(random()) as text) || &#x27;more content&#x27;, &#x27;post_time&#x27;, abs(random() % 1680750000))) from generate_series(1, 1) where username in (select username from users order by random() limit 1);

update timelines set timeline_json = json_insert(timeline_json, &#x27;$[#]&#x27;, json_object(&#x27;tweet_id&#x27;, abs(random() % 2000000), &#x27;poster_id&#x27;, abs(random() % 2000), &#x27;content&#x27;, cast(abs(random()) as text) || &#x27;more content&#x27;, &#x27;post_time&#x27;, abs(random() % 1680750000))) from generate_series(1, 1) where username in (select username from users order by random() limit 1);

update timelines set timeline_json = json_insert(timeline_json, &#x27;$[#]&#x27;, json_object(&#x27;tweet_id&#x27;, abs(random() % 2000000), &#x27;poster_id&#x27;, abs(random() % 2000), &#x27;content&#x27;, cast(abs(random()) as text) || &#x27;more content&#x27;, &#x27;post_time&#x27;, abs(random() % 1680750000))) from generate_series(1, 1) where username in (select username from users order by random() limit 1);

update timelines set timeline_json = json_insert(timeline_json, &#x27;$[#]&#x27;, json_object(&#x27;tweet_id&#x27;, abs(random() % 2000000), &#x27;poster_id&#x27;, abs(random() % 2000), &#x27;content&#x27;, cast(abs(random()) as text) || &#x27;more content&#x27;, &#x27;post_time&#x27;, abs(random() % 1680750000))) from generate_series(1, 1) where username in (select username from users order by random() limit 1);

update timelines set timeline_json = json_insert(timeline_json, &#x27;$[#]&#x27;, json_object(&#x27;tweet_id&#x27;, abs(random() % 2000000), &#x27;poster_id&#x27;, abs(random() % 2000), &#x27;content&#x27;, cast(abs(random()) as text) || &#x27;more content&#x27;, &#x27;post_time&#x27;, abs(random() % 1680750000))) from generate_series(1, 1) where username in (select username from users order by random() limit 1);

update timelines set timeline_json = json_insert(timeline_json, &#x27;$[#]&#x27;, json_object(&#x27;tweet_id&#x27;, abs(random() % 2000000), &#x27;poster_id&#x27;, abs(random() % 2000), &#x27;content&#x27;, cast(abs(random()) as text) || &#x27;more content&#x27;, &#x27;post_time&#x27;, abs(random() % 1680750000))) from generate_series(1, 1) where username in (select username from users order by random() limit 1);

update timelines set timeline_json = json_insert(timeline_json, &#x27;$[#]&#x27;, json_object(&#x27;tweet_id&#x27;, abs(random() % 2000000), &#x27;poster_id&#x27;, abs(random() % 2000), &#x27;content&#x27;, cast(abs(random()) as text) || &#x27;more content&#x27;, &#x27;post_time&#x27;, abs(random() % 1680750000))) from generate_series(1, 1) where username in (select username from users order by random() limit 1);

update timelines set timeline_json = json_insert(timeline_json, &#x27;$[#]&#x27;, json_object(&#x27;tweet_id&#x27;, abs(random() % 2000000), &#x27;poster_id&#x27;, abs(random() % 2000), &#x27;content&#x27;, cast(abs(random()) as text) || &#x27;more content&#x27;, &#x27;post_time&#x27;, abs(random() % 1680750000))) from generate_series(1, 1) where username in (select username from users order by random() limit 1);

update timelines set timeline_json = json_insert(timeline_json, &#x27;$[#]&#x27;, json_object(&#x27;tweet_id&#x27;, abs(random() % 2000000), &#x27;poster_id&#x27;, abs(random() % 2000), &#x27;content&#x27;, cast(abs(random()) as text) || &#x27;more content&#x27;, &#x27;post_time&#x27;, abs(random() % 1680750000))) from generate_series(1, 1) where username in (select username from users order by random() limit 1);

update timelines set timeline_json = json_insert(timeline_json, &#x27;$[#]&#x27;, json_object(&#x27;tweet_id&#x27;, abs(random() % 2000000), &#x27;poster_id&#x27;, abs(random() % 2000), &#x27;content&#x27;, cast(abs(random()) as text) || &#x27;more content&#x27;, &#x27;post_time&#x27;, abs(random() % 1680750000))) from generate_series(1, 1) where username in (select username from users order by random() limit 1);

update timelines set timeline_json = json_insert(timeline_json, &#x27;$[#]&#x27;, json_object(&#x27;tweet_id&#x27;, abs(random() % 2000000), &#x27;poster_id&#x27;, abs(random() % 2000), &#x27;content&#x27;, cast(abs(random()) as text) || &#x27;more content&#x27;, &#x27;post_time&#x27;, abs(random() % 1680750000))) from generate_series(1, 1) where username in (select username from users order by random() limit 1);

update timelines set timeline_json = json_insert(timeline_json, &#x27;$[#]&#x27;, json_object(&#x27;tweet_id&#x27;, abs(random() % 2000000), &#x27;poster_id&#x27;, abs(random() % 2000), &#x27;content&#x27;, cast(abs(random()) as text) || &#x27;more content&#x27;, &#x27;post_time&#x27;, abs(random() % 1680750000))) from generate_series(1, 1) where username in (select username from users order by random() limit 1);

update timelines set timeline_json = json_insert(timeline_json, &#x27;$[#]&#x27;, json_object(&#x27;tweet_id&#x27;, abs(random() % 2000000), &#x27;poster_id&#x27;, abs(random() % 2000), &#x27;content&#x27;, cast(abs(random()) as text) || &#x27;more content&#x27;, &#x27;post_time&#x27;, abs(random() % 1680750000))) from generate_series(1, 1) where username in (select username from users order by random() limit 1);

update timelines set timeline_json = json_insert(timeline_json, &#x27;$[#]&#x27;, json_object(&#x27;tweet_id&#x27;, abs(random() % 2000000), &#x27;poster_id&#x27;, abs(random() % 2000), &#x27;content&#x27;, cast(abs(random()) as text) || &#x27;more content&#x27;, &#x27;post_time&#x27;, abs(random() % 1680750000))) from generate_series(1, 1) where username in (select username from users order by random() limit 1);

update timelines set timeline_json = json_insert(timeline_json, &#x27;$[#]&#x27;, json_object(&#x27;tweet_id&#x27;, abs(random() % 2000000), &#x27;poster_id&#x27;, abs(random() % 2000), &#x27;content&#x27;, cast(abs(random()) as text) || &#x27;more content&#x27;, &#x27;post_time&#x27;, abs(random() % 1680750000))) from generate_series(1, 1) where username in (select username from users order by random() limit 1);

update timelines set timeline_json = json_insert(timeline_json, &#x27;$[#]&#x27;, json_object(&#x27;tweet_id&#x27;, abs(random() % 2000000), &#x27;poster_id&#x27;, abs(random() % 2000), &#x27;content&#x27;, cast(abs(random()) as text) || &#x27;more content&#x27;, &#x27;post_time&#x27;, abs(random() % 1680750000))) from generate_series(1, 1) where username in (select username from users order by random() limit 1);

update timelines set timeline_json = json_insert(timeline_json, &#x27;$[#]&#x27;, json_object(&#x27;tweet_id&#x27;, abs(random() % 2000000), &#x27;poster_id&#x27;, abs(random() % 2000), &#x27;content&#x27;, cast(abs(random()) as text) || &#x27;more content&#x27;, &#x27;post_time&#x27;, abs(random() % 1680750000))) from generate_series(1, 1) where username in (select username from users order by random() limit 1);

update timelines set timeline_json = json_insert(timeline_json, &#x27;$[#]&#x27;, json_object(&#x27;tweet_id&#x27;, abs(random() % 2000000), &#x27;poster_id&#x27;, abs(random() % 2000), &#x27;content&#x27;, cast(abs(random()) as text) || &#x27;more content&#x27;, &#x27;post_time&#x27;, abs(random() % 1680750000))) from generate_series(1, 1) where username in (select username from users order by random() limit 1);

update timelines set timeline_json = json_insert(timeline_json, &#x27;$[#]&#x27;, json_object(&#x27;tweet_id&#x27;, abs(random() % 2000000), &#x27;poster_id&#x27;, abs(random() % 2000), &#x27;content&#x27;, cast(abs(random()) as text) || &#x27;more content&#x27;, &#x27;post_time&#x27;, abs(random() % 1680750000))) from generate_series(1, 1) where username in (select username from users order by random() limit 1);

update timelines set timeline_json = json_insert(timeline_json, &#x27;$[#]&#x27;, json_object(&#x27;tweet_id&#x27;, abs(random() % 2000000), &#x27;poster_id&#x27;, abs(random() % 2000), &#x27;content&#x27;, cast(abs(random()) as text) || &#x27;more content&#x27;, &#x27;post_time&#x27;, abs(random() % 1680750000))) from generate_series(1, 1) where username in (select username from users order by random() limit 1);

update timelines set timeline_json = json_insert(timeline_json, &#x27;$[#]&#x27;, json_object(&#x27;tweet_id&#x27;, abs(random() % 2000000), &#x27;poster_id&#x27;, abs(random() % 2000), &#x27;content&#x27;, cast(abs(random()) as text) || &#x27;more content&#x27;, &#x27;post_time&#x27;, abs(random() % 1680750000))) from generate_series(1, 1) where username in (select username from users order by random() limit 1);

update timelines set timeline_json = json_insert(timeline_json, &#x27;$[#]&#x27;, json_object(&#x27;tweet_id&#x27;, abs(random() % 2000000), &#x27;poster_id&#x27;, abs(random() % 2000), &#x27;content&#x27;, cast(abs(random()) as text) || &#x27;more content&#x27;, &#x27;post_time&#x27;, abs(random() % 1680750000))) from generate_series(1, 1) where username in (select username from users order by random() limit 1);

update timelines set timeline_json = json_insert(timeline_json, &#x27;$[#]&#x27;, json_object(&#x27;tweet_id&#x27;, abs(random() % 2000000), &#x27;poster_id&#x27;, abs(random() % 2000), &#x27;content&#x27;, cast(abs(random()) as text) || &#x27;more content&#x27;, &#x27;post_time&#x27;, abs(random() % 1680750000))) from generate_series(1, 1) where username in (select username from users order by random() limit 1);

update timelines set timeline_json = json_insert(timeline_json, &#x27;$[#]&#x27;, json_object(&#x27;tweet_id&#x27;, abs(random() % 2000000), &#x27;poster_id&#x27;, abs(random() % 2000), &#x27;content&#x27;, cast(abs(random()) as text) || &#x27;more content&#x27;, &#x27;post_time&#x27;, abs(random() % 1680750000))) from generate_series(1, 1) where username in (select username from users order by random() limit 1);

update timelines set timeline_json = json_insert(timeline_json, &#x27;$[#]&#x27;, json_object(&#x27;tweet_id&#x27;, abs(random() % 2000000), &#x27;poster_id&#x27;, abs(random() % 2000), &#x27;content&#x27;, cast(abs(random()) as text) || &#x27;more content&#x27;, &#x27;post_time&#x27;, abs(random() % 1680750000))) from generate_series(1, 1) where username in (select username from users order by random() limit 1);

update timelines set timeline_json = json_insert(timeline_json, &#x27;$[#]&#x27;, json_object(&#x27;tweet_id&#x27;, abs(random() % 2000000), &#x27;poster_id&#x27;, abs(random() % 2000), &#x27;content&#x27;, cast(abs(random()) as text) || &#x27;more content&#x27;, &#x27;post_time&#x27;, abs(random() % 1680750000))) from generate_series(1, 1) where username in (select username from users order by random() limit 1);

update timelines set timeline_json = json_insert(timeline_json, &#x27;$[#]&#x27;, json_object(&#x27;tweet_id&#x27;, abs(random() % 2000000), &#x27;poster_id&#x27;, abs(random() % 2000), &#x27;content&#x27;, cast(abs(random()) as text) || &#x27;more content&#x27;, &#x27;post_time&#x27;, abs(random() % 1680750000))) from generate_series(1, 1) where username in (select username from users order by random() limit 1);

update timelines set timeline_json = json_insert(timeline_json, &#x27;$[#]&#x27;, json_object(&#x27;tweet_id&#x27;, abs(random() % 2000000), &#x27;poster_id&#x27;, abs(random() % 2000), &#x27;content&#x27;, cast(abs(random()) as text) || &#x27;more content&#x27;, &#x27;post_time&#x27;, abs(random() % 1680750000))) from generate_series(1, 1) where username in (select username from users order by random() limit 1);

update timelines set timeline_json = json_insert(timeline_json, &#x27;$[#]&#x27;, json_object(&#x27;tweet_id&#x27;, abs(random() % 2000000), &#x27;poster_id&#x27;, abs(random() % 2000), &#x27;content&#x27;, cast(abs(random()) as text) || &#x27;more content&#x27;, &#x27;post_time&#x27;, abs(random() % 1680750000))) from generate_series(1, 1) where username in (select username from users order by random() limit 1);

update timelines set timeline_json = json_insert(timeline_json, &#x27;$[#]&#x27;, json_object(&#x27;tweet_id&#x27;, abs(random() % 2000000), &#x27;poster_id&#x27;, abs(random() % 2000), &#x27;content&#x27;, cast(abs(random()) as text) || &#x27;more content&#x27;, &#x27;post_time&#x27;, abs(random() % 1680750000))) from generate_series(1, 1) where username in (select username from users order by random() limit 1);

update timelines set timeline_json = json_insert(timeline_json, &#x27;$[#]&#x27;, json_object(&#x27;tweet_id&#x27;, abs(random() % 2000000), &#x27;poster_id&#x27;, abs(random() % 2000), &#x27;content&#x27;, cast(abs(random()) as text) || &#x27;more content&#x27;, &#x27;post_time&#x27;, abs(random() % 1680750000))) from generate_series(1, 1) where username in (select username from users order by random() limit 1);

update timelines set timeline_json = json_insert(timeline_json, &#x27;$[#]&#x27;, json_object(&#x27;tweet_id&#x27;, abs(random() % 2000000), &#x27;poster_id&#x27;, abs(random() % 2000), &#x27;content&#x27;, cast(abs(random()) as text) || &#x27;more content&#x27;, &#x27;post_time&#x27;, abs(random() % 1680750000))) from generate_series(1, 1) where username in (select username from users order by random() limit 1);

update timelines set timeline_json = json_insert(timeline_json, &#x27;$[#]&#x27;, json_object(&#x27;tweet_id&#x27;, abs(random() % 2000000), &#x27;poster_id&#x27;, abs(random() % 2000), &#x27;content&#x27;, cast(abs(random()) as text) || &#x27;more content&#x27;, &#x27;post_time&#x27;, abs(random() % 1680750000))) from generate_series(1, 1) where username in (select username from users order by random() limit 1);

update timelines set timeline_json = json_insert(timeline_json, &#x27;$[#]&#x27;, json_object(&#x27;tweet_id&#x27;, abs(random() % 2000000), &#x27;poster_id&#x27;, abs(random() % 2000), &#x27;content&#x27;, cast(abs(random()) as text) || &#x27;more content&#x27;, &#x27;post_time&#x27;, abs(random() % 1680750000))) from generate_series(1, 1) where username in (select username from users order by random() limit 1);

update timelines set timeline_json = json_insert(timeline_json, &#x27;$[#]&#x27;, json_object(&#x27;tweet_id&#x27;, abs(random() % 2000000), &#x27;poster_id&#x27;, abs(random() % 2000), &#x27;content&#x27;, cast(abs(random()) as text) || &#x27;more content&#x27;, &#x27;post_time&#x27;, abs(random() % 1680750000))) from generate_series(1, 1) where username in (select username from users order by random() limit 1);

update timelines set timeline_json = json_insert(timeline_json, &#x27;$[#]&#x27;, json_object(&#x27;tweet_id&#x27;, abs(random() % 2000000), &#x27;poster_id&#x27;, abs(random() % 2000), &#x27;content&#x27;, cast(abs(random()) as text) || &#x27;more content&#x27;, &#x27;post_time&#x27;, abs(random() % 1680750000))) from generate_series(1, 1) where username in (select username from users order by random() limit 1);

update timelines set timeline_json = json_insert(timeline_json, &#x27;$[#]&#x27;, json_object(&#x27;tweet_id&#x27;, abs(random() % 2000000), &#x27;poster_id&#x27;, abs(random() % 2000), &#x27;content&#x27;, cast(abs(random()) as text) || &#x27;more content&#x27;, &#x27;post_time&#x27;, abs(random() % 1680750000))) from generate_series(1, 1) where username in (select username from users order by random() limit 1);

update timelines set timeline_json = json_insert(timeline_json, &#x27;$[#]&#x27;, json_object(&#x27;tweet_id&#x27;, abs(random() % 2000000), &#x27;poster_id&#x27;, abs(random() % 2000), &#x27;content&#x27;, cast(abs(random()) as text) || &#x27;more content&#x27;, &#x27;post_time&#x27;, abs(random() % 1680750000))) from generate_series(1, 1) where username in (select username from users order by random() limit 1);

update timelines set timeline_json = json_insert(timeline_json, &#x27;$[#]&#x27;, json_object(&#x27;tweet_id&#x27;, abs(random() % 2000000), &#x27;poster_id&#x27;, abs(random() % 2000), &#x27;content&#x27;, cast(abs(random()) as text) || &#x27;more content&#x27;, &#x27;post_time&#x27;, abs(random() % 1680750000))) from generate_series(1, 1) where username in (select username from users order by random() limit 1);

update timelines set timeline_json = json_insert(timeline_json, &#x27;$[#]&#x27;, json_object(&#x27;tweet_id&#x27;, abs(random() % 2000000), &#x27;poster_id&#x27;, abs(random() % 2000), &#x27;content&#x27;, cast(abs(random()) as text) || &#x27;more content&#x27;, &#x27;post_time&#x27;, abs(random() % 1680750000))) from generate_series(1, 1) where username in (select username from users order by random() limit 1);

update timelines set timeline_json = json_insert(timeline_json, &#x27;$[#]&#x27;, json_object(&#x27;tweet_id&#x27;, abs(random() % 2000000), &#x27;poster_id&#x27;, abs(random() % 2000), &#x27;content&#x27;, cast(abs(random()) as text) || &#x27;more content&#x27;, &#x27;post_time&#x27;, abs(random() % 1680750000))) from generate_series(1, 1) where username in (select username from users order by random() limit 1);

update timelines set timeline_json = json_insert(timeline_json, &#x27;$[#]&#x27;, json_object(&#x27;tweet_id&#x27;, abs(random() % 2000000), &#x27;poster_id&#x27;, abs(random() % 2000), &#x27;content&#x27;, cast(abs(random()) as text) || &#x27;more content&#x27;, &#x27;post_time&#x27;, abs(random() % 1680750000))) from generate_series(1, 1) where username in (select username from users order by random() limit 1);

update timelines set timeline_json = json_insert(timeline_json, &#x27;$[#]&#x27;, json_object(&#x27;tweet_id&#x27;, abs(random() % 2000000), &#x27;poster_id&#x27;, abs(random() % 2000), &#x27;content&#x27;, cast(abs(random()) as text) || &#x27;more content&#x27;, &#x27;post_time&#x27;, abs(random() % 1680750000))) from generate_series(1, 1) where username in (select username from users order by random() limit 1);

update timelines set timeline_json = json_insert(timeline_json, &#x27;$[#]&#x27;, json_object(&#x27;tweet_id&#x27;, abs(random() % 2000000), &#x27;poster_id&#x27;, abs(random() % 2000), &#x27;content&#x27;, cast(abs(random()) as text) || &#x27;more content&#x27;, &#x27;post_time&#x27;, abs(random() % 1680750000))) from generate_series(1, 1) where username in (select username from users order by random() limit 1);

update timelines set timeline_json = json_insert(timeline_json, &#x27;$[#]&#x27;, json_object(&#x27;tweet_id&#x27;, abs(random() % 2000000), &#x27;poster_id&#x27;, abs(random() % 2000), &#x27;content&#x27;, cast(abs(random()) as text) || &#x27;more content&#x27;, &#x27;post_time&#x27;, abs(random() % 1680750000))) from generate_series(1, 1) where username in (select username from users order by random() limit 1);

update timelines set timeline_json = json_insert(timeline_json, &#x27;$[#]&#x27;, json_object(&#x27;tweet_id&#x27;, abs(random() % 2000000), &#x27;poster_id&#x27;, abs(random() % 2000), &#x27;content&#x27;, cast(abs(random()) as text) || &#x27;more content&#x27;, &#x27;post_time&#x27;, abs(random() % 1680750000))) from generate_series(1, 1) where username in (select username from users order by random() limit 1);

update timelines set timeline_json = json_insert(timeline_json, &#x27;$[#]&#x27;, json_object(&#x27;tweet_id&#x27;, abs(random() % 2000000), &#x27;poster_id&#x27;, abs(random() % 2000), &#x27;content&#x27;, cast(abs(random()) as text) || &#x27;more content&#x27;, &#x27;post_time&#x27;, abs(random() % 1680750000))) from generate_series(1, 1) where username in (select username from users order by random() limit 1);

update timelines set timeline_json = json_insert(timeline_json, &#x27;$[#]&#x27;, json_object(&#x27;tweet_id&#x27;, abs(random() % 2000000), &#x27;poster_id&#x27;, abs(random() % 2000), &#x27;content&#x27;, cast(abs(random()) as text) || &#x27;more content&#x27;, &#x27;post_time&#x27;, abs(random() % 1680750000))) from generate_series(1, 1) where username in (select username from users order by random() limit 1);

update timelines set timeline_json = json_insert(timeline_json, &#x27;$[#]&#x27;, json_object(&#x27;tweet_id&#x27;, abs(random() % 2000000), &#x27;poster_id&#x27;, abs(random() % 2000), &#x27;content&#x27;, cast(abs(random()) as text) || &#x27;more content&#x27;, &#x27;post_time&#x27;, abs(random() % 1680750000))) from generate_series(1, 1) where username in (select username from users order by random() limit 1);

update timelines set timeline_json = json_insert(timeline_json, &#x27;$[#]&#x27;, json_object(&#x27;tweet_id&#x27;, abs(random() % 2000000), &#x27;poster_id&#x27;, abs(random() % 2000), &#x27;content&#x27;, cast(abs(random()) as text) || &#x27;more content&#x27;, &#x27;post_time&#x27;, abs(random() % 1680750000))) from generate_series(1, 1) where username in (select username from users order by random() limit 1);

update timelines set timeline_json = json_insert(timeline_json, &#x27;$[#]&#x27;, json_object(&#x27;tweet_id&#x27;, abs(random() % 2000000), &#x27;poster_id&#x27;, abs(random() % 2000), &#x27;content&#x27;, cast(abs(random()) as text) || &#x27;more content&#x27;, &#x27;post_time&#x27;, abs(random() % 1680750000))) from generate_series(1, 1) where username in (select username from users order by random() limit 1);

update timelines set timeline_json = json_insert(timeline_json, &#x27;$[#]&#x27;, json_object(&#x27;tweet_id&#x27;, abs(random() % 2000000), &#x27;poster_id&#x27;, abs(random() % 2000), &#x27;content&#x27;, cast(abs(random()) as text) || &#x27;more content&#x27;, &#x27;post_time&#x27;, abs(random() % 1680750000))) from generate_series(1, 1) where username in (select username from users order by random() limit 1);

update timelines set timeline_json = json_insert(timeline_json, &#x27;$[#]&#x27;, json_object(&#x27;tweet_id&#x27;, abs(random() % 2000000), &#x27;poster_id&#x27;, abs(random() % 2000), &#x27;content&#x27;, cast(abs(random()) as text) || &#x27;more content&#x27;, &#x27;post_time&#x27;, abs(random() % 1680750000))) from generate_series(1, 1) where username in (select username from users order by random() limit 1);

update timelines set timeline_json = json_insert(timeline_json, &#x27;$[#]&#x27;, json_object(&#x27;tweet_id&#x27;, abs(random() % 2000000), &#x27;poster_id&#x27;, abs(random() % 2000), &#x27;content&#x27;, cast(abs(random()) as text) || &#x27;more content&#x27;, &#x27;post_time&#x27;, abs(random() % 1680750000))) from generate_series(1, 1) where username in (select username from users order by random() limit 1);

update timelines set timeline_json = json_insert(timeline_json, &#x27;$[#]&#x27;, json_object(&#x27;tweet_id&#x27;, abs(random() % 2000000), &#x27;poster_id&#x27;, abs(random() % 2000), &#x27;content&#x27;, cast(abs(random()) as text) || &#x27;more content&#x27;, &#x27;post_time&#x27;, abs(random() % 1680750000))) from generate_series(1, 1) where username in (select username from users order by random() limit 1);

update timelines set timeline_json = json_insert(timeline_json, &#x27;$[#]&#x27;, json_object(&#x27;tweet_id&#x27;, abs(random() % 2000000), &#x27;poster_id&#x27;, abs(random() % 2000), &#x27;content&#x27;, cast(abs(random()) as text) || &#x27;more content&#x27;, &#x27;post_time&#x27;, abs(random() % 1680750000))) from generate_series(1, 1) where username in (select username from users order by random() limit 1);

update timelines set timeline_json = json_insert(timeline_json, &#x27;$[#]&#x27;, json_object(&#x27;tweet_id&#x27;, abs(random() % 2000000), &#x27;poster_id&#x27;, abs(random() % 2000), &#x27;content&#x27;, cast(abs(random()) as text) || &#x27;more content&#x27;, &#x27;post_time&#x27;, abs(random() % 1680750000))) from generate_series(1, 1) where username in (select username from users order by random() limit 1);

update timelines set timeline_json = json_insert(timeline_json, &#x27;$[#]&#x27;, json_object(&#x27;tweet_id&#x27;, abs(random() % 2000000), &#x27;poster_id&#x27;, abs(random() % 2000), &#x27;content&#x27;, cast(abs(random()) as text) || &#x27;more content&#x27;, &#x27;post_time&#x27;, abs(random() % 1680750000))) from generate_series(1, 1) where username in (select username from users order by random() limit 1);

update timelines set timeline_json = json_insert(timeline_json, &#x27;$[#]&#x27;, json_object(&#x27;tweet_id&#x27;, abs(random() % 2000000), &#x27;poster_id&#x27;, abs(random() % 2000), &#x27;content&#x27;, cast(abs(random()) as text) || &#x27;more content&#x27;, &#x27;post_time&#x27;, abs(random() % 1680750000))) from generate_series(1, 1) where username in (select username from users order by random() limit 1);

update timelines set timeline_json = json_insert(timeline_json, &#x27;$[#]&#x27;, json_object(&#x27;tweet_id&#x27;, abs(random() % 2000000), &#x27;poster_id&#x27;, abs(random() % 2000), &#x27;content&#x27;, cast(abs(random()) as text) || &#x27;more content&#x27;, &#x27;post_time&#x27;, abs(random() % 1680750000))) from generate_series(1, 1) where username in (select username from users order by random() limit 1);

update timelines set timeline_json = json_insert(timeline_json, &#x27;$[#]&#x27;, json_object(&#x27;tweet_id&#x27;, abs(random() % 2000000), &#x27;poster_id&#x27;, abs(random() % 2000), &#x27;content&#x27;, cast(abs(random()) as text) || &#x27;more content&#x27;, &#x27;post_time&#x27;, abs(random() % 1680750000))) from generate_series(1, 1) where username in (select username from users order by random() limit 1);

update timelines set timeline_json = json_insert(timeline_json, &#x27;$[#]&#x27;, json_object(&#x27;tweet_id&#x27;, abs(random() % 2000000), &#x27;poster_id&#x27;, abs(random() % 2000), &#x27;content&#x27;, cast(abs(random()) as text) || &#x27;more content&#x27;, &#x27;post_time&#x27;, abs(random() % 1680750000))) from generate_series(1, 1) where username in (select username from users order by random() limit 1);

update timelines set timeline_json = json_insert(timeline_json, &#x27;$[#]&#x27;, json_object(&#x27;tweet_id&#x27;, abs(random() % 2000000), &#x27;poster_id&#x27;, abs(random() % 2000), &#x27;content&#x27;, cast(abs(random()) as text) || &#x27;more content&#x27;, &#x27;post_time&#x27;, abs(random() % 1680750000))) from generate_series(1, 1) where username in (select username from users order by random() limit 1);

update timelines set timeline_json = json_insert(timeline_json, &#x27;$[#]&#x27;, json_object(&#x27;tweet_id&#x27;, abs(random() % 2000000), &#x27;poster_id&#x27;, abs(random() % 2000), &#x27;content&#x27;, cast(abs(random()) as text) || &#x27;more content&#x27;, &#x27;post_time&#x27;, abs(random() % 1680750000))) from generate_series(1, 1) where username in (select username from users order by random() limit 1);

update timelines set timeline_json = json_insert(timeline_json, &#x27;$[#]&#x27;, json_object(&#x27;tweet_id&#x27;, abs(random() % 2000000), &#x27;poster_id&#x27;, abs(random() % 2000), &#x27;content&#x27;, cast(abs(random()) as text) || &#x27;more content&#x27;, &#x27;post_time&#x27;, abs(random() % 1680750000))) from generate_series(1, 1) where username in (select username from users order by random() limit 1);

update timelines set timeline_json = json_insert(timeline_json, &#x27;$[#]&#x27;, json_object(&#x27;tweet_id&#x27;, abs(random() % 2000000), &#x27;poster_id&#x27;, abs(random() % 2000), &#x27;content&#x27;, cast(abs(random()) as text) || &#x27;more content&#x27;, &#x27;post_time&#x27;, abs(random() % 1680750000))) from generate_series(1, 1) where username in (select username from users order by random() limit 1);

update timelines set timeline_json = json_insert(timeline_json, &#x27;$[#]&#x27;, json_object(&#x27;tweet_id&#x27;, abs(random() % 2000000), &#x27;poster_id&#x27;, abs(random() % 2000), &#x27;content&#x27;, cast(abs(random()) as text) || &#x27;more content&#x27;, &#x27;post_time&#x27;, abs(random() % 1680750000))) from generate_series(1, 1) where username in (select username from users order by random() limit 1);

update timelines set timeline_json = json_insert(timeline_json, &#x27;$[#]&#x27;, json_object(&#x27;tweet_id&#x27;, abs(random() % 2000000), &#x27;poster_id&#x27;, abs(random() % 2000), &#x27;content&#x27;, cast(abs(random()) as text) || &#x27;more content&#x27;, &#x27;post_time&#x27;, abs(random() % 1680750000))) from generate_series(1, 1) where username in (select username from users order by random() limit 1);

update timelines set timeline_json = json_insert(timeline_json, &#x27;$[#]&#x27;, json_object(&#x27;tweet_id&#x27;, abs(random() % 2000000), &#x27;poster_id&#x27;, abs(random() % 2000), &#x27;content&#x27;, cast(abs(random()) as text) || &#x27;more content&#x27;, &#x27;post_time&#x27;, abs(random() % 1680750000))) from generate_series(1, 1) where username in (select username from users order by random() limit 1);

commit;
</code></pre></details></li></ul><p id="ff2369b3-a2fe-402a-80f6-b1d0b194977c" class="">
</p><p id="c1948942-e88f-4551-910f-eaec786b0768" class="">TODO this runs pretty quick because sqlite is awesome and we don’t have that much data in this example, but you can imagine how if a user had millions of followers it would be really slow if you tried to insert into millions of timelines each time that user posted.</p><p id="3935b270-cc67-4d54-a661-2e96a0b7720d" class="">
</p><p id="19cf252e-563a-410e-85ba-ceaa89ffd505" class="">TODO conclude blah blah</p><p id="f5cc888e-3117-418d-8ee5-dd050df1665b" class="">random stuff</p><pre id="e9da68a3-e78d-4aed-90d2-61b98dc635e3" class="code code-wrap"><code>select json_array_length(timeline_json) from timelines where username = &#x27;alice&#x27;;</code></pre></div></article></body></html>